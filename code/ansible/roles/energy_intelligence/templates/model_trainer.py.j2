#!/usr/bin/env python3
"""
Model Trainer - Entra√Ænement des mod√®les ML √©nerg√©tiques
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/model_trainer.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
import joblib
import sys

def generate_training_data():
    """G√©n√©ration de donn√©es d'entra√Ænement simul√©es"""
    print("üìä G√©n√©ration des donn√©es d'entra√Ænement...")
    
    # G√©n√©rer 30 jours de donn√©es horaires
    dates = pd.date_range(
        start=datetime.now() - timedelta(days=30),
        end=datetime.now(),
        freq='H'
    )
    
    data = []
    for i, date in enumerate(dates):
        hour = date.hour
        day_of_week = date.weekday()
        month = date.month
        
        # Simulation patterns r√©alistes
        base_consumption = 80 + 20 * np.sin(hour * np.pi / 12)  # Cycle quotidien
        weekend_factor = 0.8 if day_of_week >= 5 else 1.0
        seasonal_factor = 1.2 if month in [6, 7, 8] else 1.0  # √ât√©
        
        consumption = base_consumption * weekend_factor * seasonal_factor
        consumption += np.random.normal(0, 5)  # Bruit
        
        # Production solaire
        if 6 <= hour <= 18:
            solar = 60 * np.sin((hour - 6) * np.pi / 12) * np.random.uniform(0.7, 1.0)
        else:
            solar = 0
            
        # M√©t√©o simul√©e
        temp = 20 + 10 * np.sin((hour - 6) * np.pi / 12) + np.random.normal(0, 3)
        cloud_cover = np.random.uniform(0, 100)
        
        data.append({
            'timestamp': date,
            'hour': hour,
            'day_of_week': day_of_week,
            'month': month,
            'temperature': temp,
            'cloud_cover': cloud_cover,
            'solar_production': max(0, solar),
            'consumption': max(50, consumption),
            'battery_level': np.random.uniform(20, 95)
        })
    
    df = pd.DataFrame(data)
    print(f"‚úÖ {len(df)} √©chantillons g√©n√©r√©s")
    return df

def train_consumption_model(df):
    """Entra√Ænement du mod√®le de pr√©diction de consommation"""
    print("üîß Entra√Ænement mod√®le de consommation...")
    
    # Features pour pr√©diction consommation
    features = ['hour', 'day_of_week', 'month', 'temperature']
    X = df[features]
    y = df['consumption']
    
    # Split train/test
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # Entra√Ænement
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    
    # √âvaluation
    y_pred = model.predict(X_test)
    mae = mean_absolute_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    
    print(f"  üìà MAE: {mae:.2f}%")
    print(f"  üìà R¬≤: {r2:.3f}")
    
    # Sauvegarde
    model_path = "{{ energy_ai_paths.models | default('/opt/energy-ai/models') }}/battery_model.joblib"
    joblib.dump(model, model_path)
    print(f"  üíæ Mod√®le sauvegard√©: {model_path}")
    
    return model, {'mae': mae, 'r2': r2}

def generate_training_report(models_metrics):
    """G√©n√©ration du rapport d'entra√Ænement"""
    print("üìä G√©n√©ration du rapport d'entra√Ænement...")
    
    report = {
        'timestamp': datetime.now().isoformat(),
        'training_version': '{{ energy_ai.version | default("1.0.0") }}',
        'models_trained': len(models_metrics),
        'metrics': models_metrics,
        'summary': {
            'best_model': max(models_metrics.keys(), key=lambda k: models_metrics[k]['r2']),
            'avg_r2': np.mean([m['r2'] for m in models_metrics.values()]),
            'training_data_samples': 720  # 30 jours * 24h
        }
    }
    
    # Sauvegarde du rapport
    report_path = "{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/training_report.json"
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"üìÑ Rapport sauvegard√©: {report_path}")
    return report

def main():
    """Point d'entr√©e principal"""
    print("üöÄ ENTRA√éNEMENT MOD√àLES ENERGY AI")
    print("=" * 50)
    print(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    try:
        # V√©rifier r√©pertoire mod√®les
        models_dir = "{{ energy_ai_paths.models | default('/opt/energy-ai/models') }}"
        import os
        os.makedirs(models_dir, exist_ok=True)
        
        # G√©n√©ration des donn√©es
        df = generate_training_data()
        
        # Entra√Ænement des mod√®les
        models_metrics = {}
        
        print("\nüîß ENTRA√éNEMENT DES MOD√àLES")
        print("-" * 30)
        
        # Mod√®le consommation
        _, metrics = train_consumption_model(df)
        models_metrics['consumption'] = metrics
        
        # Mod√®le solaire
        _, metrics = train_solar_model(df)
        models_metrics['solar'] = metrics
        
        # Mod√®le batterie
        _, metrics = train_battery_model(df)
        models_metrics['battery'] = metrics
        
        # Rapport final
        print("\nüìä RAPPORT D'ENTRA√éNEMENT")
        print("-" * 30)
        
        report = generate_training_report(models_metrics)
        
        print("\n‚úÖ ENTRA√éNEMENT TERMIN√â")
        print("=" * 50)
        print(f"üéØ Mod√®les entra√Æn√©s: {len(models_metrics)}")
        print(f"üìà R¬≤ moyen: {report['summary']['avg_r2']:.3f}")
        print(f"üèÜ Meilleur mod√®le: {report['summary']['best_model']}")
        print("\nüí° Les mod√®les sont pr√™ts pour la production!")
        
        return 0
        
    except Exception as e:
        print(f"‚ùå Erreur lors de l'entra√Ænement: {e}")
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code))
    
    # √âvaluation
    y_pred = model.predict(X_test)
    mae = mean_absolute_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    
    print(f"  üìà MAE: {mae:.2f} kW")
    print(f"  üìà R¬≤: {r2:.3f}")
    
    # Sauvegarde
    model_path = "{{ energy_ai_paths.models | default('/opt/energy-ai/models') }}/consumption_model.joblib"
    joblib.dump(model, model_path)
    print(f"  üíæ Mod√®le sauvegard√©: {model_path}")
    
    return model, {'mae': mae, 'r2': r2}

def train_solar_model(df):
    """Entra√Ænement du mod√®le de pr√©diction solaire"""
    print("üîß Entra√Ænement mod√®le de production solaire...")
    
    # Features pour pr√©diction solaire
    features = ['hour', 'month', 'temperature', 'cloud_cover']
    X = df[features]
    y = df['solar_production']
    
    # Split train/test
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # Entra√Ænement
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    
    # √âvaluation
    y_pred = model.predict(X_test)
    mae = mean_absolute_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    
    print(f"  üìà MAE: {mae:.2f} kW")
    print(f"  üìà R¬≤: {r2:.3f}")
    
    # Sauvegarde
    model_path = "{{ energy_ai_paths.models | default('/opt/energy-ai/models') }}/solar_model.joblib"
    joblib.dump(model, model_path)
    print(f"  üíæ Mod√®le sauvegard√©: {model_path}")
    
    return model, {'mae': mae, 'r2': r2}

def train_battery_model(df):
    """Entra√Ænement du mod√®le d'optimisation batterie"""
    print("üîß Entra√Ænement mod√®le d'optimisation batterie...")
    
    # Cr√©er target optimal pour batterie
    df['optimal_battery'] = df.apply(lambda row: 
        90 if 10 <= row['hour'] <= 14 and row['solar_production'] > 30  # Charge solaire
        else 30 if 18 <= row['hour'] <= 22  # D√©charge heures pleines
        else 70,  # Maintien
        axis=1
    )
    
    features = ['hour', 'solar_production', 'consumption', 'battery_level']
    X = df[features]
    y = df['optimal_battery']
    
    # Split train/test
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # Entra√Ænement
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train