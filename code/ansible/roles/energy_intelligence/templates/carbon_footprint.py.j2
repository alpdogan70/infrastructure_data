#!/usr/bin/env python3
"""
Carbon Footprint Calculator - Calculateur d'empreinte carbone
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/carbon_footprint.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
from datetime import datetime, timedelta
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "carbon_metrics"

# Facteurs d'√©mission CO2 (gCO2/kWh)
CARBON_FACTORS = {
    'grid_electricity_france': 79,  # Mix √©lectrique fran√ßais 2023
    'solar_pv': 41,  # Cycle de vie panneaux solaires
    'battery_storage': 15,  # Stockage batterie lithium
    'natural_gas': 490,  # Gaz naturel
    'coal': 820,  # Charbon
    'nuclear': 12,  # Nucl√©aire
    'wind': 11,  # √âolien
    'hydro': 24  # Hydraulique
}

# Facteurs de compensation (gCO2 √©vit√©s/kWh)
CARBON_AVOIDANCE = {
    'solar_autoconsumption': 79,  # √âvite r√©seau fran√ßais
    'battery_optimization': 25,  # Optimisation stockage
    'efficiency_improvement': 15,  # Am√©lioration efficacit√©
    'load_shifting': 10  # Report de charge
}

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/carbon_footprint.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('CarbonFootprint')

class CarbonFootprintCalculator:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.current_data = {}
        self.daily_emissions = {}
        self.carbon_targets = self.initialize_targets()
        
    def initialize_targets(self):
        """Initialisation des objectifs carbone"""
        return {
            'daily_target_kg_co2': 50.0,  # Objectif quotidien
            'monthly_target_kg_co2': 1500.0,  # Objectif mensuel
            'annual_target_kg_co2': 18000.0,  # Objectif annuel
            'reduction_target_pct': 15,  # R√©duction vis√©e par an
            'carbon_neutrality_year': 2030  # Objectif neutralit√© carbone
        }
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="carbon-footprint-calculator")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"‚úÖ Connect√© au broker MQTT {MQTT_BROKER}")
                    # S'abonner aux topics √©nerg√©tiques
                    topics = [
                        "energy/+/+",
                        "sensors/+/energy",
                        "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/executed",
                        "{{ mqtt_ai.topics.cost_optimization | default('energy/ai/costs') }}/results"
                    ]
                    for topic in topics:
                        client.subscribe(topic)
                        logger.info(f"üì° Abonn√© au topic: {topic}")
                else:
                    logger.error(f"‚ùå √âchec connexion MQTT: {rc}")
                    
            def on_message(client, userdata, msg):
                try:
                    topic = msg.topic
                    payload = json.loads(msg.payload.decode())
                    self.process_energy_data(topic, payload)
                except Exception as e:
                    logger.error(f"‚ùå Erreur traitement message MQTT: {e}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.on_message = on_message
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion √† InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            logger.info("‚úÖ Connect√© √† InfluxDB")
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion InfluxDB: {e}")
            
    def process_energy_data(self, topic, data):
        """Traitement des donn√©es √©nerg√©tiques pour calcul carbone"""
        try:
            self.current_data[topic] = {
                'data': data,
                'timestamp': datetime.now()
            }
            
            # Calculer empreinte si assez de donn√©es
            if len(self.current_data) >= 3:
                self.calculate_carbon_footprint()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement donn√©es: {e}")
            
    def extract_energy_metrics(self):
        """Extraction des m√©triques √©nerg√©tiques"""
        metrics = {
            'grid_consumption_kw': 0.0,
            'solar_production_kw': 0.0,
            'solar_autoconsumption_kw': 0.0,
            'battery_charge_kw': 0.0,
            'battery_discharge_kw': 0.0,
            'total_consumption_kw': 85.0  # D√©faut
        }
        
        # Extraction depuis les donn√©es MQTT
        for topic, data_info in self.current_data.items():
            data = data_info['data']
            
            if 'grid' in topic and 'power' in data:
                grid_power = float(data['power'])
                if grid_power > 0:
                    metrics['grid_consumption_kw'] = grid_power
                    
            elif 'solar' in topic and 'power' in data:
                metrics['solar_production_kw'] = float(data['power'])
                
            elif 'consumption' in topic and 'power' in data:
                metrics['total_consumption_kw'] = float(data['power'])
                
            elif 'battery' in topic:
                if 'charge_power' in data:
                    metrics['battery_charge_kw'] = float(data['charge_power'])
                if 'discharge_power' in data:
                    metrics['battery_discharge_kw'] = float(data['discharge_power'])
                    
        # Calcul autoconsommation solaire
        solar_used_directly = min(
            metrics['solar_production_kw'],
            metrics['total_consumption_kw'] - metrics['battery_discharge_kw']
        )
        metrics['solar_autoconsumption_kw'] = max(0, solar_used_directly)
        
        return metrics
        
    def calculate_carbon_footprint(self):
        """Calcul de l'empreinte carbone"""
        try:
            metrics = self.extract_energy_metrics()
            
            # √âmissions directes (gCO2/h)
            grid_emissions = metrics['grid_consumption_kw'] * CARBON_FACTORS['grid_electricity_france']
            solar_lifecycle_emissions = metrics['solar_production_kw'] * CARBON_FACTORS['solar_pv']
            battery_emissions = (metrics['battery_charge_kw'] + metrics['battery_discharge_kw']) * CARBON_FACTORS['battery_storage']
            
            total_emissions_g_per_hour = grid_emissions + solar_lifecycle_emissions + battery_emissions
            
            # √âmissions √©vit√©es (gCO2/h)
            solar_avoidance = metrics['solar_autoconsumption_kw'] * CARBON_AVOIDANCE['solar_autoconsumption']
            battery_optimization_avoidance = metrics['battery_discharge_kw'] * CARBON_AVOIDANCE['battery_optimization']
            
            total_avoidance_g_per_hour = solar_avoidance + battery_optimization_avoidance
            
            # Bilan net
            net_emissions_g_per_hour = total_emissions_g_per_hour - total_avoidance_g_per_hour
            
            # Intensit√© carbone
            carbon_intensity = net_emissions_g_per_hour / max(1, metrics['total_consumption_kw'])
            
            carbon_footprint = {
                'timestamp': datetime.now().isoformat(),
                'emissions': {
                    'grid_consumption_g_co2_h': round(grid_emissions, 2),
                    'solar_lifecycle_g_co2_h': round(solar_lifecycle_emissions, 2),
                    'battery_operations_g_co2_h': round(battery_emissions, 2),
                    'total_emissions_g_co2_h': round(total_emissions_g_per_hour, 2)
                },
                'avoidance': {
                    'solar_autoconsumption_g_co2_h': round(solar_avoidance, 2),
                    'battery_optimization_g_co2_h': round(battery_optimization_avoidance, 2),
                    'total_avoidance_g_co2_h': round(total_avoidance_g_per_hour, 2)
                },
                'net_balance': {
                    'net_emissions_g_co2_h': round(net_emissions_g_per_hour, 2),
                    'net_emissions_kg_co2_day': round(net_emissions_g_per_hour * 24 / 1000, 3),
                    'carbon_intensity_g_co2_kwh': round(carbon_intensity, 2)
                },
                'energy_metrics': metrics,
                'performance_indicators': self.calculate_performance_indicators(net_emissions_g_per_hour)
            }
            
            # Publication et sauvegarde
            self.publish_carbon_data(carbon_footprint)
            self.save_to_influxdb(carbon_footprint)
            
            # V√©rifier objectifs
            self.check_carbon_targets(carbon_footprint)
            
            return carbon_footprint
            
        except Exception as e:
            logger.error(f"‚ùå Erreur calcul empreinte carbone: {e}")
            return {}
            
    def calculate_performance_indicators(self, net_emissions_g_per_hour):
        """Calcul des indicateurs de performance carbone"""
        try:
            daily_projection_kg = (net_emissions_g_per_hour * 24) / 1000
            
            # Comparaison avec objectifs
            daily_target = self.carbon_targets['daily_target_kg_co2']
            target_achievement_pct = min(100, max(0, (1 - daily_projection_kg / daily_target) * 100))
            
            # Classification performance
            if daily_projection_kg <= daily_target * 0.8:
                performance_level = "excellent"
            elif daily_projection_kg <= daily_target:
                performance_level = "good"
            elif daily_projection_kg <= daily_target * 1.2:
                performance_level = "acceptable"
            else:
                performance_level = "needs_improvement"
                
            # √âquivalents pour perspective
            annual_projection_kg = daily_projection_kg * 365
            tree_equivalent = annual_projection_kg / 22  # 1 arbre absorbe ~22kg CO2/an
            car_km_equivalent = daily_projection_kg / 0.12  # ~120g CO2/km voiture moyenne
            
            return {
                'daily_projection_kg_co2': round(daily_projection_kg, 3),
                'target_achievement_pct': round(target_achievement_pct, 1),
                'performance_level': performance_level,
                'annual_projection_kg_co2': round(annual_projection_kg, 1),
                'tree_offset_equivalent': round(tree_equivalent, 1),
                'car_km_equivalent': round(car_km_equivalent, 1),
                'vs_french_avg_datacenter': self.compare_to_benchmark(daily_projection_kg)
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur calcul indicateurs: {e}")
            return {}
            
    def compare_to_benchmark(self, daily_kg_co2):
        """Comparaison avec benchmark datacenter fran√ßais moyen"""
        # Benchmark datacenter fran√ßais moyen: ~60kg CO2/jour pour taille similaire
        french_datacenter_avg = 60.0
        
        if daily_kg_co2 <= french_datacenter_avg * 0.7:
            return "30% better than average"
        elif daily_kg_co2 <= french_datacenter_avg:
            return "better than average"
        elif daily_kg_co2 <= french_datacenter_avg * 1.3:
            return "close to average"
        else:
            return "above average"
            
    def check_carbon_targets(self, carbon_footprint):
        """V√©rification des objectifs carbone"""
        try:
            daily_projection = carbon_footprint['performance_indicators']['daily_projection_kg_co2']
            daily_target = self.carbon_targets['daily_target_kg_co2']
            
            alerts = []
            
            # Alerte d√©passement objectif quotidien
            if daily_projection > daily_target:
                excess_pct = ((daily_projection / daily_target) - 1) * 100
                alerts.append({
                    'type': 'daily_target_exceeded',
                    'severity': 'warning' if excess_pct < 20 else 'critical',
                    'message': f"Objectif quotidien d√©pass√© de {excess_pct:.1f}%",
                    'excess_kg_co2': round(daily_projection - daily_target, 2)
                })
                
            # Alerte tendance mensuelle
            monthly_projection = daily_projection * 30
            monthly_target = self.carbon_targets['monthly_target_kg_co2']
            
            if monthly_projection > monthly_target:
                alerts.append({
                    'type': 'monthly_trend_warning',
                    'severity': 'warning',
                    'message': f"Tendance mensuelle au-dessus de l'objectif",
                    'projected_monthly_kg_co2': round(monthly_projection, 1)
                })
                
            # Recommandations de r√©duction
            recommendations = self.generate_reduction_recommendations(carbon_footprint)
            
            if alerts or recommendations:
                self.publish_carbon_alerts(alerts, recommendations)
                
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification objectifs: {e}")
            
    def generate_reduction_recommendations(self, carbon_footprint):
        """G√©n√©ration de recommandations de r√©duction carbone"""
        try:
            recommendations = []
            metrics = carbon_footprint['energy_metrics']
            emissions = carbon_footprint['emissions']
            
            # Recommandation: Augmenter autoconsommation solaire
            solar_production = metrics['solar_production_kw']
            solar_autoconsumption = metrics['solar_autoconsumption_kw']
            
            if solar_production > 0 and solar_autoconsumption / solar_production < 0.8:
                potential_reduction = (solar_production - solar_autoconsumption) * CARBON_AVOIDANCE['solar_autoconsumption']
                recommendations.append({
                    'action': 'increase_solar_autoconsumption',
                    'description': 'Augmenter l\'autoconsommation solaire',
                    'potential_reduction_g_co2_h': round(potential_reduction, 2),
                    'implementation': 'Optimiser timing consommation avec production'
                })
                
            # Recommandation: Optimiser usage batterie
            battery_efficiency = metrics['battery_discharge_kw'] / max(1, metrics['battery_charge_kw'])
            if battery_efficiency < 0.85:  # Efficacit√© batterie faible
                recommendations.append({
                    'action': 'optimize_battery_usage',
                    'description': 'Optimiser l\'efficacit√© de la batterie',
                    'potential_reduction_g_co2_h': 150,
                    'implementation': 'R√©duire cycles charge/d√©charge inutiles'
                })
                
            # Recommandation: R√©duire consommation r√©seau
            grid_consumption = metrics['grid_consumption_kw']
            if grid_consumption > 50:  # Seuil √† ajuster
                grid_reduction_potential = min(10, grid_consumption * 0.1)  # 10% max
                potential_reduction = grid_reduction_potential * CARBON_FACTORS['grid_electricity_france']
                recommendations.append({
                    'action': 'reduce_grid_consumption',
                    'description': 'R√©duire la consommation r√©seau',
                    'potential_reduction_g_co2_h': round(potential_reduction, 2),
                    'implementation': 'Report charges non-critiques vers heures solaires'
                })
                
            return recommendations
            
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©ration recommandations: {e}")
            return []
            
    def publish_carbon_data(self, carbon_footprint):
        """Publication des donn√©es carbone"""
        try:
            if self.mqtt_client:
                # Donn√©es compl√®tes
                carbon_topic = "energy/carbon/footprint"
                self.mqtt_client.publish(carbon_topic, json.dumps(carbon_footprint, indent=2), qos=1)
                
                # M√©triques simplifi√©es pour dashboards
                summary_topic = "energy/carbon/summary"
                summary = {
                    'timestamp': carbon_footprint['timestamp'],
                    'net_emissions_kg_co2_day': carbon_footprint['net_balance']['net_emissions_kg_co2_day'],
                    'carbon_intensity_g_co2_kwh': carbon_footprint['net_balance']['carbon_intensity_g_co2_kwh'],
                    'performance_level': carbon_footprint['performance_indicators']['performance_level'],
                    'target_achievement_pct': carbon_footprint['performance_indicators']['target_achievement_pct']
                }
                self.mqtt_client.publish(summary_topic, json.dumps(summary), qos=1)
                
                logger.info("üì° Donn√©es carbone publi√©es sur MQTT")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur publication carbone: {e}")
            
    def publish_carbon_alerts(self, alerts, recommendations):
        """Publication des alertes carbone"""
        try:
            if self.mqtt_client:
                alert_data = {
                    'timestamp': datetime.now().isoformat(),
                    'alerts': alerts,
                    'recommendations': recommendations,
                    'total_alerts': len(alerts),
                    'total_recommendations': len(recommendations)
                }
                
                alert_topic = "energy/carbon/alerts"
                self.mqtt_client.publish(alert_topic, json.dumps(alert_data, indent=2), qos=2)
                
                logger.warning(f"üö® {len(alerts)} alertes carbone publi√©es")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur publication alertes: {e}")
            
    def save_to_influxdb(self, carbon_footprint):
        """Sauvegarde des donn√©es carbone dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point principal empreinte carbone
                point = Point("carbon_footprint") \
                    .tag("source", "carbon_calculator") \
                    .tag("performance_level", carbon_footprint['performance_indicators']['performance_level']) \
                    .field("net_emissions_g_co2_h", carbon_footprint['net_balance']['net_emissions_g_co2_h']) \
                    .field("net_emissions_kg_co2_day", carbon_footprint['net_balance']['net_emissions_kg_co2_day']) \
                    .field("carbon_intensity_g_co2_kwh", carbon_footprint['net_balance']['carbon_intensity_g_co2_kwh']) \
                    .field("target_achievement_pct", carbon_footprint['performance_indicators']['target_achievement_pct']) \
                    .field("total_emissions_g_co2_h", carbon_footprint['emissions']['total_emissions_g_co2_h']) \
                    .field("total_avoidance_g_co2_h", carbon_footprint['avoidance']['total_avoidance_g_co2_h']) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                
                # Points d√©taill√©s par source d'√©mission
                for source, value in carbon_footprint['emissions'].items():
                    if source != 'total_emissions_g_co2_h':
                        emission_point = Point("carbon_emissions_by_source") \
                            .tag("emission_source", source.replace('_g_co2_h', '')) \
                            .tag("source", "carbon_calculator") \
                            .field("emissions_g_co2_h", value) \
                            .time(datetime.utcnow(), WritePrecision.S)
                        
                        write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=emission_point)
                        
                logger.info("üíæ Donn√©es carbone sauvegard√©es dans InfluxDB")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde InfluxDB: {e}")
            
    def generate_monthly_report(self):
        """G√©n√©ration du rapport mensuel carbone"""
        try:
            current_month = datetime.now().strftime('%Y-%m')
            
            # Simulation donn√©es mensuelles
            monthly_report = {
                'month': current_month,
                'total_emissions_kg_co2': round(np.random.uniform(1200, 1800), 1),
                'emissions_avoided_kg_co2': round(np.random.uniform(300, 600), 1),
                'net_emissions_kg_co2': 0,  # Calcul√© apr√®s
                'carbon_intensity_avg_g_co2_kwh': round(np.random.uniform(45, 85), 2),
                'target_achievement_pct': round(np.random.uniform(85, 110), 1),
                'improvement_vs_last_month_pct': round(np.random.uniform(-5, 15), 1),
                'top_emission_sources': [
                    {'source': 'grid_consumption', 'percentage': 65},
                    {'source': 'solar_lifecycle', 'percentage': 25},
                    {'source': 'battery_operations', 'percentage': 10}
                ],
                'reduction_opportunities': [
                    {'opportunity': 'Increased solar autoconsumption', 'potential_kg_co2': 120},
                    {'opportunity': 'Battery optimization', 'potential_kg_co2': 80},
                    {'opportunity': 'Load shifting', 'potential_kg_co2': 50}
                ]
            }
            
            monthly_report['net_emissions_kg_co2'] = (
                monthly_report['total_emissions_kg_co2'] - 
                monthly_report['emissions_avoided_kg_co2']
            )
            
            # Publication du rapport
            report_topic = "energy/carbon/monthly_report"
            self.mqtt_client.publish(report_topic, json.dumps(monthly_report, indent=2), qos=1)
            
            logger.info(f"üìä Rapport mensuel carbone g√©n√©r√© - {monthly_report['net_emissions_kg_co2']}kg CO2 net")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©ration rapport mensuel: {e}")
            
    def start(self):
        """D√©marrage du calculateur d'empreinte carbone"""
        logger.info("üöÄ D√©marrage Carbon Footprint Calculator")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des t√¢ches
        schedule.every(5).minutes.do(self.calculate_carbon_footprint)
        schedule.every().hour.at(":00").do(self.calculate_carbon_footprint)
        schedule.every().month.do(self.generate_monthly_report)
        
        # Premier calcul imm√©diat
        time.sleep(5)  # Attendre premi√®res donn√©es
        self.calculate_carbon_footprint()
        
        logger.info("‚úÖ Carbon Footprint Calculator op√©rationnel")
        logger.info(f"üéØ Objectif quotidien: {self.carbon_targets['daily_target_kg_co2']}kg CO2")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)
                
        except KeyboardInterrupt:
            logger.info("üõë Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arr√™t"""
        logger.info("üßπ Nettoyage avant arr√™t")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("üëã Carbon Footprint Calculator arr√™t√© proprement")

def main():
    """Point d'entr√©e principal"""
    try:
        calculator = CarbonFootprintCalculator()
        calculator.start()
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()