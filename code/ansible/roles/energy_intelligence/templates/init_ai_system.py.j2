#!/usr/bin/env python3
"""
AI System Initialization - Initialisation du syst√®me IA √©nerg√©tique
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/init_ai_system.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import sys
import os
from datetime import datetime
import subprocess

# Configuration
ENERGY_AI_BASE = "{{ energy_ai_paths.base | default('/opt/energy-ai') }}"
VENV_PATH = "{{ python_ai.venv_path | default('/opt/energy-ai/venv') }}"
LOG_PATH = "{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}"

# Services √† initialiser
SERVICES = [
    "energy-ai-predictor",
    "energy-scenarios", 
    "weather-ml",
    "cost-optimizer"
]

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f'{LOG_PATH}/init_ai_system.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('AISystemInit')

def check_prerequisites():
    """V√©rification des pr√©requis syst√®me"""
    logger.info("üîç V√©rification des pr√©requis syst√®me")
    
    checks = []
    
    # V√©rifier Python venv
    if os.path.exists(f"{VENV_PATH}/bin/python"):
        checks.append(("Python venv", True, f"Trouv√©: {VENV_PATH}"))
    else:
        checks.append(("Python venv", False, f"Manquant: {VENV_PATH}"))
    
    # V√©rifier r√©pertoires
    for path_name, path in [
        ("Base directory", ENERGY_AI_BASE),
        ("Logs directory", LOG_PATH),
        ("Models directory", "{{ energy_ai_paths.models | default('/opt/energy-ai/models') }}"),
        ("Data directory", "{{ energy_ai_paths.data | default('/opt/energy-ai/data') }}")
    ]:
        if os.path.exists(path):
            checks.append((path_name, True, f"Existe: {path}"))
        else:
            checks.append((path_name, False, f"Manquant: {path}"))
    
    # V√©rifier scripts IA
    scripts = [
        "energy_predictor.py",
        "scenario_engine.py", 
        "weather_ml_model.py",
        "cost_optimizer.py",
        "carbon_footprint.py"
    ]
    
    for script in scripts:
        script_path = f"{ENERGY_AI_BASE}/{script}"
        if os.path.exists(script_path):
            checks.append((f"Script {script}", True, "Pr√©sent"))
        else:
            checks.append((f"Script {script}", False, "Manquant"))
    
    # Afficher r√©sultats
    logger.info("üìã R√©sultats v√©rification pr√©requis:")
    success_count = 0
    for name, status, detail in checks:
        icon = "‚úÖ" if status else "‚ùå"
        logger.info(f"  {icon} {name}: {detail}")
        if status:
            success_count += 1
    
    success_rate = (success_count / len(checks)) * 100
    logger.info(f"üìä Taux de r√©ussite: {success_rate:.1f}% ({success_count}/{len(checks)})")
    
    return success_rate >= 80.0

def test_python_modules():
    """Test des modules Python requis"""
    logger.info("üêç Test des modules Python IA")
    
    python_cmd = f"{VENV_PATH}/bin/python"
    modules_to_test = [
        "numpy",
        "pandas", 
        "sklearn",
        "paho.mqtt.client",
        "influxdb_client",
        "requests",
        "schedule"
    ]
    
    results = []
    for module in modules_to_test:
        try:
            result = subprocess.run(
                [python_cmd, "-c", f"import {module}; print(f'{module}: OK')"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                results.append((module, True, "Import√© avec succ√®s"))
                logger.info(f"  ‚úÖ {module}: OK")
            else:
                results.append((module, False, result.stderr.strip()))
                logger.error(f"  ‚ùå {module}: {result.stderr.strip()}")
                
        except Exception as e:
            results.append((module, False, str(e)))
            logger.error(f"  ‚ùå {module}: {e}")
    
    success_count = sum(1 for _, status, _ in results if status)
    logger.info(f"üìä Modules Python: {success_count}/{len(modules_to_test)} OK")
    
    return success_count >= len(modules_to_test) * 0.8

def test_ai_scripts():
    """Test de syntaxe des scripts IA"""
    logger.info("üìù Test de syntaxe des scripts IA")
    
    python_cmd = f"{VENV_PATH}/bin/python"
    scripts = [
        "energy_predictor.py",
        "scenario_engine.py",
        "weather_ml_model.py", 
        "cost_optimizer.py",
        "carbon_footprint.py"
    ]
    
    results = []
    for script in scripts:
        script_path = f"{ENERGY_AI_BASE}/{script}"
        
        if not os.path.exists(script_path):
            results.append((script, False, "Fichier manquant"))
            logger.warning(f"  ‚ö†Ô∏è {script}: Fichier manquant")
            continue
            
        try:
            # Test compilation
            result = subprocess.run(
                [python_cmd, "-m", "py_compile", script_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                results.append((script, True, "Syntaxe OK"))
                logger.info(f"  ‚úÖ {script}: Syntaxe OK")
            else:
                results.append((script, False, result.stderr.strip()))
                logger.error(f"  ‚ùå {script}: {result.stderr.strip()}")
                
        except Exception as e:
            results.append((script, False, str(e)))
            logger.error(f"  ‚ùå {script}: {e}")
    
    success_count = sum(1 for _, status, _ in results if status)
    logger.info(f"üìä Scripts IA: {success_count}/{len(scripts)} OK")
    
    return success_count >= len(scripts) * 0.8

def initialize_services():
    """Initialisation des services systemd"""
    logger.info("‚öôÔ∏è Initialisation des services systemd")
    
    results = []
    
    for service in SERVICES:
        try:
            # V√©rifier si le service existe
            check_result = subprocess.run(
                ["systemctl", "status", service],
                capture_output=True,
                text=True
            )
            
            if "could not be found" in check_result.stderr:
                results.append((service, False, "Service non trouv√©"))
                logger.warning(f"  ‚ö†Ô∏è {service}: Service non trouv√©")
                continue
            
            # Recharger systemd
            subprocess.run(["systemctl", "daemon-reload"], check=True)
            
            # Activer le service
            enable_result = subprocess.run(
                ["systemctl", "enable", service],
                capture_output=True,
                text=True
            )
            
            if enable_result.returncode == 0:
                results.append((service, True, "Activ√©"))
                logger.info(f"  ‚úÖ {service}: Activ√©")
            else:
                results.append((service, False, enable_result.stderr.strip()))
                logger.error(f"  ‚ùå {service}: {enable_result.stderr.strip()}")
                
        except Exception as e:
            results.append((service, False, str(e)))
            logger.error(f"  ‚ùå {service}: {e}")
    
    success_count = sum(1 for _, status, _ in results if status)
    logger.info(f"üìä Services: {success_count}/{len(SERVICES)} activ√©s")
    
    return results

def create_config_files():
    """Cr√©ation des fichiers de configuration par d√©faut"""
    logger.info("üìã Cr√©ation des fichiers de configuration")
    
    config_dir = "{{ energy_ai_paths.configs | default('/opt/energy-ai/configs') }}"
    os.makedirs(config_dir, exist_ok=True)
    
    configs = {
        "energy_ai_config.yaml": {
            "version": "{{ energy_ai.version | default('1.0.0') }}",
            "environment": "{{ energy_ai.environment | default('production') }}",
            "services": {
                "predictor": {"enabled": True, "interval_minutes": 15},
                "scenarios": {"enabled": True, "check_interval_seconds": 30},
                "weather_ml": {"enabled": True, "update_interval_minutes": 15},
                "cost_optimizer": {"enabled": True, "optimization_interval_minutes": 10}
            },
            "mqtt": {
                "broker": "{{ mqtt_broker_host | default('localhost') }}",
                "port": 1883,
                "username": "iot",
                "topics": {
                    "predictions": "{{ mqtt_ai.topics.predictions | default('energy/ai/predictions') }}",
                    "scenarios": "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}",
                    "weather": "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}",
                    "costs": "{{ mqtt_ai.topics.cost_optimization | default('energy/ai/costs') }}"
                }
            },
            "influxdb": {
                "url": "{{ influxdb_url | default('http://localhost:8086') }}",
                "org": "{{ influxdb_org | default('iot') }}",
                "buckets": {
                    "energy_ai": "energy_ai",
                    "scenarios": "energy_scenarios", 
                    "weather": "weather_ml",
                    "costs": "cost_optimization",
                    "carbon": "carbon_metrics"
                }
            }
        }
    }
    
    created_files = []
    for filename, content in configs.items():
        file_path = f"{config_dir}/{filename}"
        try:
            with open(file_path, 'w') as f:
                if filename.endswith('.yaml'):
                    import yaml
                    yaml.dump(content, f, default_flow_style=False)
                else:
                    json.dump(content, f, indent=2)
            
            created_files.append(filename)
            logger.info(f"  ‚úÖ {filename}: Cr√©√©")
            
        except Exception as e:
            logger.error(f"  ‚ùå {filename}: {e}")
    
    logger.info(f"üìä Fichiers config: {len(created_files)} cr√©√©s")
    return created_files

def generate_init_report():
    """G√©n√©ration du rapport d'initialisation"""
    logger.info("üìä G√©n√©ration du rapport d'initialisation")
    
    report = {
        "timestamp": datetime.now().isoformat(),
        "initialization_status": "completed",
        "energy_ai_version": "{{ energy_ai.version | default('1.0.0') }}",
        "environment": "{{ energy_ai.environment | default('production') }}",
        "system_info": {
            "base_path": ENERGY_AI_BASE,
            "venv_path": VENV_PATH,
            "log_path": LOG_PATH
        },
        "services_configured": SERVICES,
        "next_steps": [
            "V√©rifier les logs des services: journalctl -u energy-ai-predictor -f",
            "Acc√©der aux dashboards: http://{{ ansible_default_ipv4.address | default('localhost') }}/d/energy-ai",
            "Monitorer MQTT: mosquitto_sub -h {{ mqtt_broker_host | default('localhost') }} -t 'energy/ai/+' -u iot -P iot123",
            "Consulter les m√©triques InfluxDB"
        ]
    }
    
    report_path = f"{LOG_PATH}/initialization_report.json"
    try:
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        logger.info(f"üìÑ Rapport sauvegard√©: {report_path}")
    except Exception as e:
        logger.error(f"‚ùå Erreur sauvegarde rapport: {e}")
    
    return report

def main():
    """Point d'entr√©e principal"""
    logger.info("üöÄ D√©marrage initialisation syst√®me Energy AI")
    logger.info(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    logger.info(f"üèóÔ∏è Version: {{ energy_ai.version | default('1.0.0') }}")
    logger.info(f"üåç Environnement: {{ energy_ai.environment | default('production') }}")
    
    try:
        # Phase 1: V√©rifications
        logger.info("\n" + "="*50)
        logger.info("üîç PHASE 1: V√âRIFICATIONS")
        logger.info("="*50)
        
        prereq_ok = check_prerequisites()
        if not prereq_ok:
            logger.error("‚ùå Pr√©requis insuffisants - Arr√™t de l'initialisation")
            return 1
        
        # Phase 2: Tests Python
        logger.info("\n" + "="*50) 
        logger.info("üêç PHASE 2: TESTS PYTHON")
        logger.info("="*50)
        
        modules_ok = test_python_modules()
        if not modules_ok:
            logger.warning("‚ö†Ô∏è Certains modules Python manquants - Continuer avec prudence")
        
        # Phase 3: Tests scripts IA
        logger.info("\n" + "="*50)
        logger.info("üìù PHASE 3: TESTS SCRIPTS IA") 
        logger.info("="*50)
        
        scripts_ok = test_ai_scripts()
        if not scripts_ok:
            logger.warning("‚ö†Ô∏è Probl√®mes d√©tect√©s dans les scripts IA")
        
        # Phase 4: Configuration
        logger.info("\n" + "="*50)
        logger.info("üìã PHASE 4: CONFIGURATION")
        logger.info("="*50)
        
        config_files = create_config_files()
        
        # Phase 5: Services
        logger.info("\n" + "="*50)
        logger.info("‚öôÔ∏è PHASE 5: SERVICES SYSTEMD")
        logger.info("="*50)
        
        service_results = initialize_services()
        
        # Phase 6: Rapport final
        logger.info("\n" + "="*50)
        logger.info("üìä PHASE 6: RAPPORT FINAL")
        logger.info("="*50)
        
        report = generate_init_report()
        
        # R√©sum√© final
        logger.info("\n" + "üéâ INITIALISATION TERMIN√âE üéâ")
        logger.info("="*50)
        logger.info("‚úÖ Syst√®me Energy AI initialis√© avec succ√®s")
        logger.info(f"üìä Services configur√©s: {len([r for r in service_results if r[1]])}/{len(SERVICES)}")
        logger.info(f"üìã Fichiers config: {len(config_files)}")
        logger.info("\nüöÄ Prochaines √©tapes:")
        for step in report['next_steps']:
            logger.info(f"   ‚Ä¢ {step}")
        
        return 0
        
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale lors de l'initialisation: {e}")
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)