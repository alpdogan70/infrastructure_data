#!/usr/bin/env python3
"""
Energy AI Predictor - Moteur de pr√©diction √©nerg√©tique
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/energy_predictor.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys
import os

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "energy_ai"

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/energy_predictor.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('EnergyPredictor')

class EnergyAIPredictor:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.models = {}
        self.scalers = {}
        self.last_data = {}
        self.initialize_models()
        
    def initialize_models(self):
        """Initialise les mod√®les ML pour diff√©rentes pr√©dictions"""
        # Mod√®le pour pr√©diction de consommation
        self.models['consumption'] = RandomForestRegressor(
            n_estimators=100,
            random_state=42,
            max_depth=10
        )
        
        # Mod√®le pour pr√©diction de production solaire
        self.models['solar'] = RandomForestRegressor(
            n_estimators=100,
            random_state=42,
            max_depth=10
        )
        
        # Mod√®le pour optimisation batterie
        self.models['battery'] = RandomForestRegressor(
            n_estimators=100,
            random_state=42,
            max_depth=10
        )
        
        # Scalers pour normalisation
        for key in self.models.keys():
            self.scalers[key] = StandardScaler()
            
        logger.info("‚úÖ Mod√®les IA initialis√©s avec succ√®s")
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="energy-ai-predictor")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"‚úÖ Connect√© au broker MQTT {MQTT_BROKER}")
                    # S'abonner aux topics de donn√©es
                    topics = [
                        "sensors/+/energy",
                        "energy/solar/+",
                        "energy/battery/+",
                        "energy/consumption/+"
                    ]
                    for topic in topics:
                        client.subscribe(topic)
                        logger.info(f"üì° Abonn√© au topic: {topic}")
                else:
                    logger.error(f"‚ùå √âchec connexion MQTT: {rc}")
                    
            def on_message(client, userdata, msg):
                try:
                    topic = msg.topic
                    payload = json.loads(msg.payload.decode())
                    self.process_sensor_data(topic, payload)
                except Exception as e:
                    logger.error(f"‚ùå Erreur traitement message MQTT: {e}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.on_message = on_message
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion √† InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            
            # Test de connexion
            health = self.influxdb_client.health()
            if health.status == "pass":
                logger.info("‚úÖ Connect√© √† InfluxDB")
            else:
                logger.warning("‚ö†Ô∏è InfluxDB en mode d√©grad√©")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion InfluxDB: {e}")
            
    def process_sensor_data(self, topic, data):
        """Traitement des donn√©es de capteurs en temps r√©el"""
        try:
            # Stocker les derni√®res donn√©es
            timestamp = datetime.now()
            self.last_data[topic] = {
                'data': data,
                'timestamp': timestamp
            }
            
            # D√©clencher pr√©dictions si assez de donn√©es
            if len(self.last_data) >= 3:
                self.generate_predictions()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement donn√©es capteur: {e}")
            
    def generate_predictions(self):
        """G√©n√®re les pr√©dictions √©nerg√©tiques"""
        try:
            # Simulation de pr√©dictions (√† remplacer par vraie ML)
            current_time = datetime.now()
            
            # Pr√©diction consommation (prochaines 24h)
            consumption_pred = self.predict_consumption()
            
            # Pr√©diction production solaire (prochaines 24h)
            solar_pred = self.predict_solar_production()
            
            # Optimisation batterie
            battery_optimal = self.optimize_battery()
            
            # Pr√©parer les r√©sultats
            predictions = {
                'timestamp': current_time.isoformat(),
                'horizon_hours': 24,
                'consumption_prediction': consumption_pred,
                'solar_prediction': solar_pred,
                'battery_optimization': battery_optimal,
                'confidence_score': self.calculate_confidence(),
                'ai_model': 'random_forest_v1.0',
                'version': '{{ energy_ai.version | default("1.0.0") }}'
            }
            
            # Publier les pr√©dictions
            self.publish_predictions(predictions)
            
            # Sauvegarder dans InfluxDB
            self.save_to_influxdb(predictions)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©ration pr√©dictions: {e}")
            
    def predict_consumption(self):
        """Pr√©diction de la consommation √©nerg√©tique"""
        # Simulation (√† remplacer par vraie pr√©diction ML)
        base_consumption = 85.0  # kW baseline
        
        # Facteurs simul√©s
        hour = datetime.now().hour
        day_factor = 1.2 if 8 <= hour <= 18 else 0.8  # Plus de consommation le jour
        noise = np.random.normal(0, 5)  # Variabilit√©
        
        prediction = base_consumption * day_factor + noise
        return max(50.0, min(150.0, prediction))  # Borner entre 50-150kW
        
    def predict_solar_production(self):
        """Pr√©diction de la production solaire"""
        # Simulation bas√©e sur l'heure
        hour = datetime.now().hour
        
        if 6 <= hour <= 18:  # Heures de jour
            peak_hour = 12
            distance_from_peak = abs(hour - peak_hour)
            solar_factor = max(0, 1 - (distance_from_peak / 6))
            max_production = 120.0  # kW max
            
            # Facteur m√©t√©o simul√©
            weather_factor = np.random.uniform(0.7, 1.0)
            
            prediction = max_production * solar_factor * weather_factor
        else:
            prediction = 0.0  # Pas de solaire la nuit
            
        return max(0.0, prediction)
        
    def optimize_battery(self):
        """Optimisation du niveau de batterie"""
        # Logique d'optimisation simplifi√©e
        current_hour = datetime.now().hour
        
        # Heures de charge recommand√©es (surplus solaire)
        if 10 <= current_hour <= 14:
            target_level = 90.0
        # Heures de d√©charge (pic de consommation)
        elif 18 <= current_hour <= 22:
            target_level = 40.0
        # Maintien nocturne
        else:
            target_level = 70.0
            
        # Ajouter variabilit√©
        noise = np.random.normal(0, 5)
        optimal = target_level + noise
        
        return max(20.0, min(95.0, optimal))  # Borner entre 20-95%
        
    def calculate_confidence(self):
        """Calcul du score de confiance des pr√©dictions"""
        # Facteurs de confiance simul√©s
        data_freshness = min(1.0, 300 / max(1, self.get_data_age()))  # Fra√Æcheur des donn√©es
        model_stability = 0.85  # Stabilit√© du mod√®le
        weather_certainty = np.random.uniform(0.8, 0.95)
        
        confidence = (data_freshness * 0.4 + model_stability * 0.4 + weather_certainty * 0.2)
        return round(confidence, 3)
        
    def get_data_age(self):
        """√Çge des derni√®res donn√©es en secondes"""
        if not self.last_data:
            return 3600  # 1 heure par d√©faut
            
        now = datetime.now()
        ages = [(now - data['timestamp']).total_seconds() for data in self.last_data.values()]
        return min(ages)
        
    def publish_predictions(self, predictions):
        """Publication des pr√©dictions sur MQTT"""
        try:
            if self.mqtt_client:
                topic = "{{ mqtt_ai.topics.predictions | default('energy/ai/predictions') }}/forecast"
                payload = json.dumps(predictions, indent=2)
                self.mqtt_client.publish(topic, payload, qos=1)
                logger.info(f"üì° Pr√©dictions publi√©es sur {topic}")
                
                # Publier m√©triques de performance
                perf_topic = "{{ mqtt_ai.topics.performance | default('energy/ai/performance') }}"
                perf_data = {
                    'timestamp': datetime.now().isoformat(),
                    'confidence_score': predictions['confidence_score'],
                    'prediction_count': 1,
                    'model_version': predictions['ai_model'],
                    'status': 'active'
                }
                self.mqtt_client.publish(perf_topic, json.dumps(perf_data), qos=1)
                
        except Exception as e:
            logger.error(f"‚ùå Erreur publication MQTT: {e}")
            
    def save_to_influxdb(self, predictions):
        """Sauvegarde des pr√©dictions dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point principal de pr√©diction
                point = Point("energy_ai_predictions") \
                    .tag("source", "energy_predictor") \
                    .tag("model", predictions['ai_model']) \
                    .tag("horizon", f"{predictions['horizon_hours']}h") \
                    .field("consumption_kwh", predictions['consumption_prediction']) \
                    .field("solar_kwh", predictions['solar_prediction']) \
                    .field("battery_optimal_pct", predictions['battery_optimization']) \
                    .field("confidence_score", predictions['confidence_score']) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                logger.info("üíæ Pr√©dictions sauvegard√©es dans InfluxDB")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde InfluxDB: {e}")
            
    def run_scheduled_predictions(self):
        """Ex√©cution programm√©e des pr√©dictions"""
        logger.info("‚è∞ G√©n√©ration pr√©dictions programm√©e")
        self.generate_predictions()
        
    def start(self):
        """D√©marrage du service de pr√©diction"""
        logger.info("üöÄ D√©marrage Energy AI Predictor")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des t√¢ches
        schedule.every(15).minutes.do(self.run_scheduled_predictions)
        schedule.every().hour.at(":00").do(self.run_scheduled_predictions)
        
        logger.info("‚úÖ Energy AI Predictor op√©rationnel")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)  # V√©rification chaque minute
                
        except KeyboardInterrupt:
            logger.info("üõë Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arr√™t"""
        logger.info("üßπ Nettoyage avant arr√™t")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("üëã Energy AI Predictor arr√™t√© proprement")

def main():
    """Point d'entr√©e principal"""
    try:
        predictor = EnergyAIPredictor()
        predictor.start()
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()