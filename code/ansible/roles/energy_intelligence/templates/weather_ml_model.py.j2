#!/usr/bin/env python3
"""
Weather ML Model - Mod√®le ML pour pr√©dictions m√©t√©orologiques
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/weather_ml_model.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import requests
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "weather_ml"

# API M√©t√©o (OpenWeatherMap par d√©faut)
WEATHER_API_KEY = "{{ external_apis.weather.api_key | default('demo_key') }}"
WEATHER_API_URL = "http://api.openweathermap.org/data/2.5"

# Localisation (coordonn√©es Lyon par d√©faut)
LATITUDE = 45.764
LONGITUDE = 4.836
LOCATION_NAME = "Lyon, FR"

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/weather_ml.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('WeatherML')

class WeatherMLModel:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.weather_history = []
        self.solar_efficiency_model = None
        self.initialize_models()
        
    def initialize_models(self):
        """Initialisation des mod√®les ML m√©t√©o"""
        # Mod√®le simple pour efficacit√© solaire bas√© sur conditions m√©t√©o
        self.solar_efficiency_factors = {
            'clear sky': 1.0,
            'few clouds': 0.85,
            'scattered clouds': 0.7,
            'broken clouds': 0.55,
            'shower rain': 0.4,
            'rain': 0.3,
            'thunderstorm': 0.2,
            'snow': 0.15,
            'mist': 0.6
        }
        
        logger.info("‚úÖ Mod√®les m√©t√©o ML initialis√©s")
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="weather-ml-model")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"‚úÖ Connect√© au broker MQTT {MQTT_BROKER}")
                else:
                    logger.error(f"‚ùå √âchec connexion MQTT: {rc}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion √† InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            logger.info("‚úÖ Connect√© √† InfluxDB")
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion InfluxDB: {e}")
            
    def fetch_current_weather(self):
        """R√©cup√©ration des donn√©es m√©t√©o actuelles"""
        try:
            if WEATHER_API_KEY == 'demo_key':
                # Mode d√©mo avec donn√©es simul√©es
                return self.generate_demo_weather()
                
            url = f"{WEATHER_API_URL}/weather"
            params = {
                'lat': LATITUDE,
                'lon': LONGITUDE,
                'appid': WEATHER_API_KEY,
                'units': 'metric'
            }
            
            response = requests.get(url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return self.parse_weather_data(data)
            else:
                logger.warning(f"‚ö†Ô∏è API m√©t√©o inaccessible: {response.status_code}")
                return self.generate_demo_weather()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration m√©t√©o: {e}")
            return self.generate_demo_weather()
            
    def generate_demo_weather(self):
        """G√©n√©ration de donn√©es m√©t√©o d√©mo"""
        hour = datetime.now().hour
        
        # Simulation d'une journ√©e type
        if 6 <= hour <= 18:  # Jour
            temperature = 15 + 10 * np.sin((hour - 6) * np.pi / 12) + np.random.normal(0, 2)
            cloud_cover = max(0, min(100, 30 + np.random.normal(0, 20)))
            conditions = ['clear sky', 'few clouds', 'scattered clouds'][
                int(cloud_cover / 35)
            ]
        else:  # Nuit
            temperature = 8 + np.random.normal(0, 3)
            cloud_cover = max(0, min(100, 50 + np.random.normal(0, 25)))
            conditions = 'few clouds'
            
        return {
            'timestamp': datetime.now().isoformat(),
            'location': LOCATION_NAME,
            'temperature': round(temperature, 1),
            'humidity': max(30, min(95, 60 + np.random.normal(0, 15))),
            'cloud_cover': round(cloud_cover, 1),
            'weather_condition': conditions,
            'wind_speed': max(0, np.random.normal(5, 3)),
            'pressure': round(1013 + np.random.normal(0, 10), 1),
            'uv_index': max(0, 8 * np.sin((hour - 6) * np.pi / 12)) if 6 <= hour <= 18 else 0,
            'visibility': max(1, min(10, 8 + np.random.normal(0, 2))),
            'data_source': 'demo'
        }
        
    def parse_weather_data(self, api_data):
        """Analyse des donn√©es API m√©t√©o"""
        try:
            main = api_data['main']
            weather = api_data['weather'][0]
            wind = api_data.get('wind', {})
            clouds = api_data.get('clouds', {})
            
            return {
                'timestamp': datetime.now().isoformat(),
                'location': f"{api_data['name']}, {api_data['sys']['country']}",
                'temperature': main['temp'],
                'humidity': main['humidity'],
                'cloud_cover': clouds.get('all', 0),
                'weather_condition': weather['description'],
                'wind_speed': wind.get('speed', 0),
                'pressure': main['pressure'],
                'uv_index': 0,  # N√©cessite API s√©par√©e
                'visibility': api_data.get('visibility', 10000) / 1000,
                'data_source': 'openweathermap'
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur parsing donn√©es m√©t√©o: {e}")
            return self.generate_demo_weather()
            
    def fetch_weather_forecast(self):
        """R√©cup√©ration des pr√©visions m√©t√©o"""
        try:
            if WEATHER_API_KEY == 'demo_key':
                return self.generate_demo_forecast()
                
            url = f"{WEATHER_API_URL}/forecast"
            params = {
                'lat': LATITUDE,
                'lon': LONGITUDE,
                'appid': WEATHER_API_KEY,
                'units': 'metric'
            }
            
            response = requests.get(url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return self.parse_forecast_data(data)
            else:
                return self.generate_demo_forecast()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur pr√©visions m√©t√©o: {e}")
            return self.generate_demo_forecast()
            
    def generate_demo_forecast(self):
        """G√©n√©ration de pr√©visions m√©t√©o d√©mo"""
        forecast = []
        base_time = datetime.now()
        
        for i in range(24):  # Pr√©visions 24h
            forecast_time = base_time + timedelta(hours=i)
            hour = forecast_time.hour
            
            # Simulation d'√©volution m√©t√©o
            if 6 <= hour <= 18:
                temp = 15 + 8 * np.sin((hour - 6) * np.pi / 12) + np.random.normal(0, 1)
                clouds = max(0, min(100, 25 + i * 2 + np.random.normal(0, 10)))
            else:
                temp = 8 + np.random.normal(0, 2)
                clouds = max(0, min(100, 40 + np.random.normal(0, 15)))
                
            forecast.append({
                'timestamp': forecast_time.isoformat(),
                'temperature': round(temp, 1),
                'cloud_cover': round(clouds, 1),
                'humidity': max(40, min(90, 65 + np.random.normal(0, 10))),
                'wind_speed': max(0, np.random.normal(4, 2)),
                'weather_condition': self.get_condition_from_clouds(clouds),
                'solar_efficiency': self.calculate_solar_efficiency(clouds, hour)
            })
            
        return forecast
        
    def get_condition_from_clouds(self, cloud_cover):
        """D√©termination des conditions m√©t√©o selon la couverture nuageuse"""
        if cloud_cover < 20:
            return 'clear sky'
        elif cloud_cover < 40:
            return 'few clouds'
        elif cloud_cover < 70:
            return 'scattered clouds'
        else:
            return 'broken clouds'
            
    def calculate_solar_efficiency(self, cloud_cover, hour):
        """Calcul de l'efficacit√© solaire"""
        # Efficacit√© de base selon l'heure
        if 6 <= hour <= 18:
            base_efficiency = np.sin((hour - 6) * np.pi / 12)
        else:
            base_efficiency = 0
            
        # R√©duction selon couverture nuageuse
        cloud_factor = 1 - (cloud_cover / 100) * 0.8
        
        return max(0, base_efficiency * cloud_factor)
        
    def predict_solar_production(self, weather_data):
        """Pr√©diction de production solaire bas√©e sur la m√©t√©o"""
        try:
            current = weather_data
            forecast = self.fetch_weather_forecast()
            
            predictions = []
            
            # Capacit√© install√©e (exemple: 150kW)
            installed_capacity = 150.0
            
            for forecast_point in forecast[:24]:  # 24h de pr√©visions
                condition = forecast_point['weather_condition']
                efficiency_factor = self.solar_efficiency_factors.get(condition, 0.5)
                
                # Facteur temp√©rature (optimum vers 25¬∞C)
                temp = forecast_point['temperature']
                temp_factor = 1 - abs(temp - 25) * 0.004
                temp_factor = max(0.7, min(1.0, temp_factor))
                
                # Production pr√©dite
                solar_efficiency = forecast_point.get('solar_efficiency', 0.5)
                predicted_production = (
                    installed_capacity * 
                    solar_efficiency * 
                    efficiency_factor * 
                    temp_factor
                )
                
                predictions.append({
                    'timestamp': forecast_point['timestamp'],
                    'predicted_production_kw': round(predicted_production, 2),
                    'weather_condition': condition,
                    'temperature': temp,
                    'cloud_cover': forecast_point['cloud_cover'],
                    'efficiency_factor': round(efficiency_factor, 3),
                    'temp_factor': round(temp_factor, 3)
                })
                
            return predictions
            
        except Exception as e:
            logger.error(f"‚ùå Erreur pr√©diction solaire: {e}")
            return []
            
    def analyze_weather_impact(self, weather_data):
        """Analyse de l'impact m√©t√©o sur le syst√®me √©nerg√©tique"""
        try:
            analysis = {
                'timestamp': datetime.now().isoformat(),
                'weather_score': 0.5,
                'solar_potential': 0.5,
                'cooling_demand': 0.5,
                'energy_recommendations': []
            }
            
            temp = weather_data['temperature']
            clouds = weather_data['cloud_cover']
            condition = weather_data['weather_condition']
            
            # Score m√©t√©o global (0-1)
            weather_score = self.solar_efficiency_factors.get(condition, 0.5)
            analysis['weather_score'] = weather_score
            
            # Potentiel solaire
            hour = datetime.now().hour
            if 6 <= hour <= 18:
                solar_potential = weather_score * np.sin((hour - 6) * np.pi / 12)
            else:
                solar_potential = 0
            analysis['solar_potential'] = round(solar_potential, 3)
            
            # Demande de refroidissement
            cooling_demand = max(0, (temp - 20) / 15)  # Augmente apr√®s 20¬∞C
            analysis['cooling_demand'] = round(cooling_demand, 3)
            
            # Recommandations
            recommendations = []
            
            if solar_potential > 0.7:
                recommendations.append("Optimiser charge batterie - conditions solaires excellentes")
            elif solar_potential < 0.3 and hour > 6 and hour < 18:
                recommendations.append("R√©duire consommation - faible production solaire attendue")
                
            if cooling_demand > 0.6:
                recommendations.append("Pr√©parer refroidissement - temp√©rature √©lev√©e")
            elif cooling_demand < 0.2:
                recommendations.append("R√©duire refroidissement - temp√©rature mod√©r√©e")
                
            if weather_score < 0.4:
                recommendations.append("Mode conservation √©nergie recommand√©")
                
            analysis['energy_recommendations'] = recommendations
            
            return analysis
            
        except Exception as e:
            logger.error(f"‚ùå Erreur analyse impact m√©t√©o: {e}")
            return {}
            
    def publish_weather_data(self, weather_data, analysis=None, solar_predictions=None):
        """Publication des donn√©es m√©t√©o et analyses"""
        try:
            if self.mqtt_client:
                # Donn√©es m√©t√©o actuelles
                weather_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/current"
                self.mqtt_client.publish(weather_topic, json.dumps(weather_data, indent=2), qos=1)
                
                # Analyse d'impact
                if analysis:
                    analysis_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/analysis"
                    self.mqtt_client.publish(analysis_topic, json.dumps(analysis, indent=2), qos=1)
                    
                # Pr√©dictions solaires
                if solar_predictions:
                    solar_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/solar_forecast"
                    forecast_data = {
                        'timestamp': datetime.now().isoformat(),
                        'forecast_horizon_hours': 24,
                        'predictions': solar_predictions
                    }
                    self.mqtt_client.publish(solar_topic, json.dumps(forecast_data, indent=2), qos=1)
                    
                logger.info("üì° Donn√©es m√©t√©o publi√©es sur MQTT")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur publication MQTT: {e}")
            
    def save_to_influxdb(self, weather_data, analysis=None):
        """Sauvegarde des donn√©es m√©t√©o dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point m√©t√©o principal
                point = Point("weather_data") \
                    .tag("location", weather_data['location']) \
                    .tag("condition", weather_data['weather_condition']) \
                    .tag("source", weather_data['data_source']) \
                    .field("temperature", weather_data['temperature']) \
                    .field("humidity", weather_data['humidity']) \
                    .field("cloud_cover", weather_data['cloud_cover']) \
                    .field("wind_speed", weather_data['wind_speed']) \
                    .field("pressure", weather_data['pressure']) \
                    .field("uv_index", weather_data['uv_index']) \
                    .field("visibility", weather_data['visibility']) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                
                # Point d'analyse si disponible
                if analysis:
                    analysis_point = Point("weather_analysis") \
                        .tag("location", weather_data['location']) \
                        .tag("source", "ml_model") \
                        .field("weather_score", analysis['weather_score']) \
                        .field("solar_potential", analysis['solar_potential']) \
                        .field("cooling_demand", analysis['cooling_demand']) \
                        .field("recommendations_count", len(analysis['energy_recommendations'])) \
                        .time(datetime.utcnow(), WritePrecision.S)
                    
                    write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=analysis_point)
                    
                logger.info("üíæ Donn√©es m√©t√©o sauvegard√©es dans InfluxDB")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde InfluxDB: {e}")
            
    def run_weather_update(self):
        """Mise √† jour compl√®te des donn√©es m√©t√©o"""
        try:
            logger.info("üå§Ô∏è Mise √† jour donn√©es m√©t√©o")
            
            # R√©cup√©rer donn√©es actuelles
            weather_data = self.fetch_current_weather()
            
            # Analyser impact √©nerg√©tique
            analysis = self.analyze_weather_impact(weather_data)
            
            # Pr√©dictions solaires
            solar_predictions = self.predict_solar_production(weather_data)
            
            # Publier et sauvegarder
            self.publish_weather_data(weather_data, analysis, solar_predictions)
            self.save_to_influxdb(weather_data, analysis)
            
            # Stocker dans l'historique
            self.weather_history.append({
                'timestamp': datetime.now(),
                'data': weather_data,
                'analysis': analysis
            })
            
            # Limiter l'historique √† 24h
            cutoff_time = datetime.now() - timedelta(hours=24)
            self.weather_history = [
                entry for entry in self.weather_history 
                if entry['timestamp'] > cutoff_time
            ]
            
            logger.info(f"‚úÖ Mise √† jour m√©t√©o termin√©e - {len(solar_predictions)} pr√©dictions solaires")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur mise √† jour m√©t√©o: {e}")
            
    def start(self):
        """D√©marrage du service m√©t√©o ML"""
        logger.info("üöÄ D√©marrage Weather ML Model")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des t√¢ches
        schedule.every(15).minutes.do(self.run_weather_update)
        schedule.every().hour.at(":00").do(self.run_weather_update)
        
        # Premi√®re mise √† jour imm√©diate
        self.run_weather_update()
        
        logger.info("‚úÖ Weather ML Model op√©rationnel")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)
                
        except KeyboardInterrupt:
            logger.info("üõë Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arr√™t"""
        logger.info("üßπ Nettoyage avant arr√™t")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("üëã Weather ML Model arr√™t√© proprement")

def main():
    """Point d'entr√©e principal"""
    try:
        weather_model = WeatherMLModel()
        weather_model.start()
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()