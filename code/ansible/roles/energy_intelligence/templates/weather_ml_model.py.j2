#!/usr/bin/env python3
"""
Weather ML Model - Modèle ML pour prédictions météorologiques
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/weather_ml_model.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import requests
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "weather_ml"

# API Météo (OpenWeatherMap par défaut)
WEATHER_API_KEY = "{{ external_apis.weather.api_key | default('demo_key') }}"
WEATHER_API_URL = "http://api.openweathermap.org/data/2.5"

# Localisation (coordonnées Lyon par défaut)
LATITUDE = 45.764
LONGITUDE = 4.836
LOCATION_NAME = "Lyon, FR"

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/weather_ml.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('WeatherML')

class WeatherMLModel:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.weather_history = []
        self.solar_efficiency_model = None
        self.initialize_models()
        
    def initialize_models(self):
        """Initialisation des modèles ML météo"""
        # Modèle simple pour efficacité solaire basé sur conditions météo
        self.solar_efficiency_factors = {
            'clear sky': 1.0,
            'few clouds': 0.85,
            'scattered clouds': 0.7,
            'broken clouds': 0.55,
            'shower rain': 0.4,
            'rain': 0.3,
            'thunderstorm': 0.2,
            'snow': 0.15,
            'mist': 0.6
        }
        
        logger.info("✅ Modèles météo ML initialisés")
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="weather-ml-model")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"✅ Connecté au broker MQTT {MQTT_BROKER}")
                else:
                    logger.error(f"❌ Échec connexion MQTT: {rc}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"❌ Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion à InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            logger.info("✅ Connecté à InfluxDB")
        except Exception as e:
            logger.error(f"❌ Erreur connexion InfluxDB: {e}")
            
    def fetch_current_weather(self):
        """Récupération des données météo actuelles"""
        try:
            if WEATHER_API_KEY == 'demo_key':
                # Mode démo avec données simulées
                return self.generate_demo_weather()
                
            url = f"{WEATHER_API_URL}/weather"
            params = {
                'lat': LATITUDE,
                'lon': LONGITUDE,
                'appid': WEATHER_API_KEY,
                'units': 'metric'
            }
            
            response = requests.get(url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return self.parse_weather_data(data)
            else:
                logger.warning(f"⚠️ API météo inaccessible: {response.status_code}")
                return self.generate_demo_weather()
                
        except Exception as e:
            logger.error(f"❌ Erreur récupération météo: {e}")
            return self.generate_demo_weather()
            
    def generate_demo_weather(self):
        """Génération de données météo démo"""
        hour = datetime.now().hour
        
        # Simulation d'une journée type
        if 6 <= hour <= 18:  # Jour
            temperature = 15 + 10 * np.sin((hour - 6) * np.pi / 12) + np.random.normal(0, 2)
            cloud_cover = max(0, min(100, 30 + np.random.normal(0, 20)))
            conditions = ['clear sky', 'few clouds', 'scattered clouds'][
                int(cloud_cover / 35)
            ]
        else:  # Nuit
            temperature = 8 + np.random.normal(0, 3)
            cloud_cover = max(0, min(100, 50 + np.random.normal(0, 25)))
            conditions = 'few clouds'
            
        return {
            'timestamp': datetime.now().isoformat(),
            'location': LOCATION_NAME,
            'temperature': round(temperature, 1),
            'humidity': max(30, min(95, 60 + np.random.normal(0, 15))),
            'cloud_cover': round(cloud_cover, 1),
            'weather_condition': conditions,
            'wind_speed': max(0, np.random.normal(5, 3)),
            'pressure': round(1013 + np.random.normal(0, 10), 1),
            'uv_index': max(0, 8 * np.sin((hour - 6) * np.pi / 12)) if 6 <= hour <= 18 else 0,
            'visibility': max(1, min(10, 8 + np.random.normal(0, 2))),
            'data_source': 'demo'
        }
        
    def parse_weather_data(self, api_data):
        """Analyse des données API météo"""
        try:
            main = api_data['main']
            weather = api_data['weather'][0]
            wind = api_data.get('wind', {})
            clouds = api_data.get('clouds', {})
            
            return {
                'timestamp': datetime.now().isoformat(),
                'location': f"{api_data['name']}, {api_data['sys']['country']}",
                'temperature': main['temp'],
                'humidity': main['humidity'],
                'cloud_cover': clouds.get('all', 0),
                'weather_condition': weather['description'],
                'wind_speed': wind.get('speed', 0),
                'pressure': main['pressure'],
                'uv_index': 0,  # Nécessite API séparée
                'visibility': api_data.get('visibility', 10000) / 1000,
                'data_source': 'openweathermap'
            }
            
        except Exception as e:
            logger.error(f"❌ Erreur parsing données météo: {e}")
            return self.generate_demo_weather()
            
    def fetch_weather_forecast(self):
        """Récupération des prévisions météo"""
        try:
            if WEATHER_API_KEY == 'demo_key':
                return self.generate_demo_forecast()
                
            url = f"{WEATHER_API_URL}/forecast"
            params = {
                'lat': LATITUDE,
                'lon': LONGITUDE,
                'appid': WEATHER_API_KEY,
                'units': 'metric'
            }
            
            response = requests.get(url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return self.parse_forecast_data(data)
            else:
                return self.generate_demo_forecast()
                
        except Exception as e:
            logger.error(f"❌ Erreur prévisions météo: {e}")
            return self.generate_demo_forecast()
            
    def generate_demo_forecast(self):
        """Génération de prévisions météo démo"""
        forecast = []
        base_time = datetime.now()
        
        for i in range(24):  # Prévisions 24h
            forecast_time = base_time + timedelta(hours=i)
            hour = forecast_time.hour
            
            # Simulation d'évolution météo
            if 6 <= hour <= 18:
                temp = 15 + 8 * np.sin((hour - 6) * np.pi / 12) + np.random.normal(0, 1)
                clouds = max(0, min(100, 25 + i * 2 + np.random.normal(0, 10)))
            else:
                temp = 8 + np.random.normal(0, 2)
                clouds = max(0, min(100, 40 + np.random.normal(0, 15)))
                
            forecast.append({
                'timestamp': forecast_time.isoformat(),
                'temperature': round(temp, 1),
                'cloud_cover': round(clouds, 1),
                'humidity': max(40, min(90, 65 + np.random.normal(0, 10))),
                'wind_speed': max(0, np.random.normal(4, 2)),
                'weather_condition': self.get_condition_from_clouds(clouds),
                'solar_efficiency': self.calculate_solar_efficiency(clouds, hour)
            })
            
        return forecast
        
    def get_condition_from_clouds(self, cloud_cover):
        """Détermination des conditions météo selon la couverture nuageuse"""
        if cloud_cover < 20:
            return 'clear sky'
        elif cloud_cover < 40:
            return 'few clouds'
        elif cloud_cover < 70:
            return 'scattered clouds'
        else:
            return 'broken clouds'
            
    def calculate_solar_efficiency(self, cloud_cover, hour):
        """Calcul de l'efficacité solaire"""
        # Efficacité de base selon l'heure
        if 6 <= hour <= 18:
            base_efficiency = np.sin((hour - 6) * np.pi / 12)
        else:
            base_efficiency = 0
            
        # Réduction selon couverture nuageuse
        cloud_factor = 1 - (cloud_cover / 100) * 0.8
        
        return max(0, base_efficiency * cloud_factor)
        
    def predict_solar_production(self, weather_data):
        """Prédiction de production solaire basée sur la météo"""
        try:
            current = weather_data
            forecast = self.fetch_weather_forecast()
            
            predictions = []
            
            # Capacité installée (exemple: 150kW)
            installed_capacity = 150.0
            
            for forecast_point in forecast[:24]:  # 24h de prévisions
                condition = forecast_point['weather_condition']
                efficiency_factor = self.solar_efficiency_factors.get(condition, 0.5)
                
                # Facteur température (optimum vers 25°C)
                temp = forecast_point['temperature']
                temp_factor = 1 - abs(temp - 25) * 0.004
                temp_factor = max(0.7, min(1.0, temp_factor))
                
                # Production prédite
                solar_efficiency = forecast_point.get('solar_efficiency', 0.5)
                predicted_production = (
                    installed_capacity * 
                    solar_efficiency * 
                    efficiency_factor * 
                    temp_factor
                )
                
                predictions.append({
                    'timestamp': forecast_point['timestamp'],
                    'predicted_production_kw': round(predicted_production, 2),
                    'weather_condition': condition,
                    'temperature': temp,
                    'cloud_cover': forecast_point['cloud_cover'],
                    'efficiency_factor': round(efficiency_factor, 3),
                    'temp_factor': round(temp_factor, 3)
                })
                
            return predictions
            
        except Exception as e:
            logger.error(f"❌ Erreur prédiction solaire: {e}")
            return []
            
    def analyze_weather_impact(self, weather_data):
        """Analyse de l'impact météo sur le système énergétique"""
        try:
            analysis = {
                'timestamp': datetime.now().isoformat(),
                'weather_score': 0.5,
                'solar_potential': 0.5,
                'cooling_demand': 0.5,
                'energy_recommendations': []
            }
            
            temp = weather_data['temperature']
            clouds = weather_data['cloud_cover']
            condition = weather_data['weather_condition']
            
            # Score météo global (0-1)
            weather_score = self.solar_efficiency_factors.get(condition, 0.5)
            analysis['weather_score'] = weather_score
            
            # Potentiel solaire
            hour = datetime.now().hour
            if 6 <= hour <= 18:
                solar_potential = weather_score * np.sin((hour - 6) * np.pi / 12)
            else:
                solar_potential = 0
            analysis['solar_potential'] = round(solar_potential, 3)
            
            # Demande de refroidissement
            cooling_demand = max(0, (temp - 20) / 15)  # Augmente après 20°C
            analysis['cooling_demand'] = round(cooling_demand, 3)
            
            # Recommandations
            recommendations = []
            
            if solar_potential > 0.7:
                recommendations.append("Optimiser charge batterie - conditions solaires excellentes")
            elif solar_potential < 0.3 and hour > 6 and hour < 18:
                recommendations.append("Réduire consommation - faible production solaire attendue")
                
            if cooling_demand > 0.6:
                recommendations.append("Préparer refroidissement - température élevée")
            elif cooling_demand < 0.2:
                recommendations.append("Réduire refroidissement - température modérée")
                
            if weather_score < 0.4:
                recommendations.append("Mode conservation énergie recommandé")
                
            analysis['energy_recommendations'] = recommendations
            
            return analysis
            
        except Exception as e:
            logger.error(f"❌ Erreur analyse impact météo: {e}")
            return {}
            
    def publish_weather_data(self, weather_data, analysis=None, solar_predictions=None):
        """Publication des données météo et analyses"""
        try:
            if self.mqtt_client:
                # Données météo actuelles
                weather_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/current"
                self.mqtt_client.publish(weather_topic, json.dumps(weather_data, indent=2), qos=1)
                
                # Analyse d'impact
                if analysis:
                    analysis_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/analysis"
                    self.mqtt_client.publish(analysis_topic, json.dumps(analysis, indent=2), qos=1)
                    
                # Prédictions solaires
                if solar_predictions:
                    solar_topic = "{{ mqtt_ai.topics.weather_ml | default('energy/ai/weather') }}/solar_forecast"
                    forecast_data = {
                        'timestamp': datetime.now().isoformat(),
                        'forecast_horizon_hours': 24,
                        'predictions': solar_predictions
                    }
                    self.mqtt_client.publish(solar_topic, json.dumps(forecast_data, indent=2), qos=1)
                    
                logger.info("📡 Données météo publiées sur MQTT")
                
        except Exception as e:
            logger.error(f"❌ Erreur publication MQTT: {e}")
            
    def save_to_influxdb(self, weather_data, analysis=None):
        """Sauvegarde des données météo dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point météo principal
                point = Point("weather_data") \
                    .tag("location", weather_data['location']) \
                    .tag("condition", weather_data['weather_condition']) \
                    .tag("source", weather_data['data_source']) \
                    .field("temperature", weather_data['temperature']) \
                    .field("humidity", weather_data['humidity']) \
                    .field("cloud_cover", weather_data['cloud_cover']) \
                    .field("wind_speed", weather_data['wind_speed']) \
                    .field("pressure", weather_data['pressure']) \
                    .field("uv_index", weather_data['uv_index']) \
                    .field("visibility", weather_data['visibility']) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                
                # Point d'analyse si disponible
                if analysis:
                    analysis_point = Point("weather_analysis") \
                        .tag("location", weather_data['location']) \
                        .tag("source", "ml_model") \
                        .field("weather_score", analysis['weather_score']) \
                        .field("solar_potential", analysis['solar_potential']) \
                        .field("cooling_demand", analysis['cooling_demand']) \
                        .field("recommendations_count", len(analysis['energy_recommendations'])) \
                        .time(datetime.utcnow(), WritePrecision.S)
                    
                    write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=analysis_point)
                    
                logger.info("💾 Données météo sauvegardées dans InfluxDB")
                
        except Exception as e:
            logger.error(f"❌ Erreur sauvegarde InfluxDB: {e}")
            
    def run_weather_update(self):
        """Mise à jour complète des données météo"""
        try:
            logger.info("🌤️ Mise à jour données météo")
            
            # Récupérer données actuelles
            weather_data = self.fetch_current_weather()
            
            # Analyser impact énergétique
            analysis = self.analyze_weather_impact(weather_data)
            
            # Prédictions solaires
            solar_predictions = self.predict_solar_production(weather_data)
            
            # Publier et sauvegarder
            self.publish_weather_data(weather_data, analysis, solar_predictions)
            self.save_to_influxdb(weather_data, analysis)
            
            # Stocker dans l'historique
            self.weather_history.append({
                'timestamp': datetime.now(),
                'data': weather_data,
                'analysis': analysis
            })
            
            # Limiter l'historique à 24h
            cutoff_time = datetime.now() - timedelta(hours=24)
            self.weather_history = [
                entry for entry in self.weather_history 
                if entry['timestamp'] > cutoff_time
            ]
            
            logger.info(f"✅ Mise à jour météo terminée - {len(solar_predictions)} prédictions solaires")
            
        except Exception as e:
            logger.error(f"❌ Erreur mise à jour météo: {e}")
            
    def start(self):
        """Démarrage du service météo ML"""
        logger.info("🚀 Démarrage Weather ML Model")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des tâches
        schedule.every(15).minutes.do(self.run_weather_update)
        schedule.every().hour.at(":00").do(self.run_weather_update)
        
        # Première mise à jour immédiate
        self.run_weather_update()
        
        logger.info("✅ Weather ML Model opérationnel")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)
                
        except KeyboardInterrupt:
            logger.info("🛑 Arrêt demandé par l'utilisateur")
        except Exception as e:
            logger.error(f"❌ Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arrêt"""
        logger.info("🧹 Nettoyage avant arrêt")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("👋 Weather ML Model arrêté proprement")

def main():
    """Point d'entrée principal"""
    try:
        weather_model = WeatherMLModel()
        weather_model.start()
    except Exception as e:
        logger.error(f"❌ Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()