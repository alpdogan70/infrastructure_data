#!/usr/bin/env python3
"""
Energy Scenarios Engine - Moteur de sc√©narios √©nerg√©tiques
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/scenario_engine.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
from datetime import datetime, timedelta
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "energy_scenarios"

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/scenario_engine.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('ScenarioEngine')

class EnergyScenarioEngine:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.active_scenarios = {}
        self.scenario_rules = self.load_scenario_rules()
        self.current_data = {}
        
    def load_scenario_rules(self):
        """Charge les r√®gles de sc√©narios √©nerg√©tiques"""
        return {
            'emergency_shutdown': {
                'priority': 1,
                'conditions': {
                    'battery_level': {'operator': '<', 'value': 15},
                    'grid_available': {'operator': '==', 'value': False}
                },
                'actions': [
                    {'type': 'server_shutdown', 'target': 'non_critical'},
                    {'type': 'alert', 'level': 'critical'},
                    {'type': 'battery_preserve'}
                ]
            },
            'graceful_shutdown': {
                'priority': 2,
                'conditions': {
                    'battery_level': {'operator': '<', 'value': 25},
                    'solar_production': {'operator': '<', 'value': 10}
                },
                'actions': [
                    {'type': 'server_shutdown', 'target': 'development'},
                    {'type': 'cooling_reduce', 'percentage': 30},
                    {'type': 'alert', 'level': 'warning'}
                ]
            },
            'solar_optimization': {
                'priority': 3,
                'conditions': {
                    'solar_production': {'operator': '>', 'value': 80},
                    'battery_level': {'operator': '<', 'value': 90}
                },
                'actions': [
                    {'type': 'battery_charge', 'rate': 'max'},
                    {'type': 'server_startup', 'target': 'development'},
                    {'type': 'cooling_increase', 'percentage': 20}
                ]
            },
            'peak_efficiency': {
                'priority': 4,
                'conditions': {
                    'battery_level': {'operator': '>', 'value': 80},
                    'solar_production': {'operator': '>', 'value': 100},
                    'consumption': {'operator': '<', 'value': 70}
                },
                'actions': [
                    {'type': 'server_startup', 'target': 'all_available'},
                    {'type': 'mining_enable'},
                    {'type': 'ai_training_enable'}
                ]
            },
            'night_conservation': {
                'priority': 5,
                'conditions': {
                    'time_range': {'start': '22:00', 'end': '06:00'},
                    'battery_level': {'operator': '<', 'value': 60}
                },
                'actions': [
                    {'type': 'server_shutdown', 'target': 'non_essential'},
                    {'type': 'cooling_reduce', 'percentage': 50},
                    {'type': 'lighting_reduce', 'percentage': 80}
                ]
            }
        }
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="energy-scenario-engine")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"‚úÖ Connect√© au broker MQTT {MQTT_BROKER}")
                    # S'abonner aux topics de donn√©es et pr√©dictions
                    topics = [
                        "energy/+/+",
                        "{{ mqtt_ai.topics.predictions | default('energy/ai/predictions') }}/+",
                        "bmc/+/power",
                        "sensors/battery/+",
                        "sensors/solar/+"
                    ]
                    for topic in topics:
                        client.subscribe(topic)
                        logger.info(f"üì° Abonn√© au topic: {topic}")
                else:
                    logger.error(f"‚ùå √âchec connexion MQTT: {rc}")
                    
            def on_message(client, userdata, msg):
                try:
                    topic = msg.topic
                    payload = json.loads(msg.payload.decode())
                    self.process_data(topic, payload)
                except Exception as e:
                    logger.error(f"‚ùå Erreur traitement message MQTT: {e}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.on_message = on_message
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion √† InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            logger.info("‚úÖ Connect√© √† InfluxDB")
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion InfluxDB: {e}")
            
    def process_data(self, topic, data):
        """Traitement des donn√©es en temps r√©el"""
        try:
            # Mettre √† jour les donn√©es actuelles
            self.current_data[topic] = {
                'data': data,
                'timestamp': datetime.now()
            }
            
            # √âvaluer les sc√©narios
            self.evaluate_scenarios()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement donn√©es: {e}")
            
    def evaluate_scenarios(self):
        """√âvaluation des sc√©narios bas√©s sur les donn√©es actuelles"""
        try:
            # Extraire les m√©triques actuelles
            current_metrics = self.extract_current_metrics()
            
            # √âvaluer chaque sc√©nario par ordre de priorit√©
            for scenario_name, scenario in sorted(
                self.scenario_rules.items(), 
                key=lambda x: x[1]['priority']
            ):
                if self.check_scenario_conditions(scenario, current_metrics):
                    if scenario_name not in self.active_scenarios:
                        logger.info(f"üéØ Activation sc√©nario: {scenario_name}")
                        self.execute_scenario(scenario_name, scenario)
                        self.active_scenarios[scenario_name] = {
                            'activated_at': datetime.now(),
                            'scenario': scenario
                        }
                else:
                    # D√©sactiver si plus de conditions remplies
                    if scenario_name in self.active_scenarios:
                        logger.info(f"üîÑ D√©sactivation sc√©nario: {scenario_name}")
                        del self.active_scenarios[scenario_name]
                        
        except Exception as e:
            logger.error(f"‚ùå Erreur √©valuation sc√©narios: {e}")
            
    def extract_current_metrics(self):
        """Extraction des m√©triques actuelles"""
        metrics = {
            'battery_level': 70.0,  # D√©faut
            'solar_production': 0.0,
            'consumption': 85.0,
            'grid_available': True,
            'time': datetime.now().strftime('%H:%M')
        }
        
        # Extraire des donn√©es MQTT re√ßues
        for topic, data_info in self.current_data.items():
            data = data_info['data']
            
            if 'battery' in topic and 'level' in data:
                metrics['battery_level'] = float(data['level'])
            elif 'solar' in topic and 'power' in data:
                metrics['solar_production'] = float(data['power'])
            elif 'consumption' in topic and 'power' in data:
                metrics['consumption'] = float(data['power'])
            elif 'grid' in topic and 'status' in data:
                metrics['grid_available'] = data['status'] == 'online'
                
        return metrics
        
    def check_scenario_conditions(self, scenario, metrics):
        """V√©rification des conditions d'un sc√©nario"""
        try:
            conditions = scenario['conditions']
            
            for metric_name, condition in conditions.items():
                if metric_name == 'time_range':
                    if not self.check_time_range(condition, metrics['time']):
                        return False
                else:
                    metric_value = metrics.get(metric_name, 0)
                    operator = condition['operator']
                    threshold = condition['value']
                    
                    if operator == '<' and not (metric_value < threshold):
                        return False
                    elif operator == '>' and not (metric_value > threshold):
                        return False
                    elif operator == '==' and not (metric_value == threshold):
                        return False
                    elif operator == '<=' and not (metric_value <= threshold):
                        return False
                    elif operator == '>=' and not (metric_value >= threshold):
                        return False
                        
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification conditions: {e}")
            return False
            
    def check_time_range(self, time_condition, current_time):
        """V√©rification d'une plage horaire"""
        try:
            start_time = time_condition['start']
            end_time = time_condition['end']
            
            start_hour, start_min = map(int, start_time.split(':'))
            end_hour, end_min = map(int, end_time.split(':'))
            current_hour, current_min = map(int, current_time.split(':'))
            
            start_minutes = start_hour * 60 + start_min
            end_minutes = end_hour * 60 + end_min
            current_minutes = current_hour * 60 + current_min
            
            # G√©rer les plages qui traversent minuit
            if start_minutes > end_minutes:
                return current_minutes >= start_minutes or current_minutes <= end_minutes
            else:
                return start_minutes <= current_minutes <= end_minutes
                
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification plage horaire: {e}")
            return False
            
    def execute_scenario(self, scenario_name, scenario):
        """Ex√©cution des actions d'un sc√©nario"""
        try:
            logger.info(f"üöÄ Ex√©cution sc√©nario: {scenario_name}")
            
            actions_executed = []
            
            for action in scenario['actions']:
                action_type = action['type']
                result = self.execute_action(action_type, action)
                actions_executed.append({
                    'type': action_type,
                    'result': result,
                    'timestamp': datetime.now().isoformat()
                })
                
            # Publier les r√©sultats
            self.publish_scenario_execution(scenario_name, actions_executed)
            
            # Sauvegarder dans InfluxDB
            self.save_scenario_to_influxdb(scenario_name, actions_executed)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur ex√©cution sc√©nario {scenario_name}: {e}")
            
    def execute_action(self, action_type, action_config):
        """Ex√©cution d'une action sp√©cifique"""
        try:
            if action_type == 'server_shutdown':
                return self.shutdown_servers(action_config.get('target', 'all'))
            elif action_type == 'server_startup':
                return self.startup_servers(action_config.get('target', 'all'))
            elif action_type == 'battery_charge':
                return self.control_battery_charging(action_config.get('rate', 'normal'))
            elif action_type == 'cooling_reduce':
                return self.adjust_cooling(action_config.get('percentage', 20), 'reduce')
            elif action_type == 'cooling_increase':
                return self.adjust_cooling(action_config.get('percentage', 20), 'increase')
            elif action_type == 'alert':
                return self.send_alert(action_config.get('level', 'info'))
            else:
                logger.warning(f"‚ö†Ô∏è Action non reconnue: {action_type}")
                return f"Unknown action: {action_type}"
                
        except Exception as e:
            logger.error(f"‚ùå Erreur ex√©cution action {action_type}: {e}")
            return f"Error: {e}"
            
    def shutdown_servers(self, target):
        """Arr√™t de serveurs selon la cible"""
        message = {
            'action': 'shutdown',
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'reason': 'energy_scenario'
        }
        
        topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/actions/shutdown"
        self.mqtt_client.publish(topic, json.dumps(message), qos=2)
        
        logger.info(f"üñ•Ô∏è Arr√™t serveurs demand√©: {target}")
        return f"Shutdown command sent for: {target}"
        
    def startup_servers(self, target):
        """D√©marrage de serveurs selon la cible"""
        message = {
            'action': 'startup',
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'reason': 'energy_scenario'
        }
        
        topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/actions/startup"
        self.mqtt_client.publish(topic, json.dumps(message), qos=2)
        
        logger.info(f"üñ•Ô∏è D√©marrage serveurs demand√©: {target}")
        return f"Startup command sent for: {target}"
        
    def control_battery_charging(self, rate):
        """Contr√¥le de la charge de batterie"""
        message = {
            'action': 'charge_control',
            'rate': rate,
            'timestamp': datetime.now().isoformat()
        }
        
        topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/actions/battery"
        self.mqtt_client.publish(topic, json.dumps(message), qos=2)
        
        logger.info(f"üîã Contr√¥le charge batterie: {rate}")
        return f"Battery charging set to: {rate}"
        
    def adjust_cooling(self, percentage, direction):
        """Ajustement du syst√®me de refroidissement"""
        message = {
            'action': 'cooling_adjust',
            'percentage': percentage,
            'direction': direction,
            'timestamp': datetime.now().isoformat()
        }
        
        topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/actions/cooling"
        self.mqtt_client.publish(topic, json.dumps(message), qos=2)
        
        logger.info(f"‚ùÑÔ∏è Ajustement refroidissement: {direction} {percentage}%")
        return f"Cooling {direction} by {percentage}%"
        
    def send_alert(self, level):
        """Envoi d'alerte"""
        message = {
            'action': 'alert',
            'level': level,
            'timestamp': datetime.now().isoformat(),
            'message': f"Energy scenario alert - level: {level}"
        }
        
        topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/alerts"
        self.mqtt_client.publish(topic, json.dumps(message), qos=2)
        
        logger.warning(f"üö® Alerte envoy√©e: niveau {level}")
        return f"Alert sent: {level}"
        
    def publish_scenario_execution(self, scenario_name, actions):
        """Publication de l'ex√©cution d'un sc√©nario"""
        try:
            message = {
                'scenario_name': scenario_name,
                'timestamp': datetime.now().isoformat(),
                'actions_executed': actions,
                'status': 'executed',
                'engine_version': '{{ energy_ai.version | default("1.0.0") }}'
            }
            
            topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/executed"
            self.mqtt_client.publish(topic, json.dumps(message, indent=2), qos=1)
            
            logger.info(f"üì° Ex√©cution sc√©nario publi√©e: {scenario_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur publication sc√©nario: {e}")
            
    def save_scenario_to_influxdb(self, scenario_name, actions):
        """Sauvegarde de l'ex√©cution dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point principal du sc√©nario
                point = Point("energy_scenarios_executed") \
                    .tag("scenario", scenario_name) \
                    .tag("source", "scenario_engine") \
                    .tag("version", "{{ energy_ai.version | default('1.0.0') }}") \
                    .field("actions_count", len(actions)) \
                    .field("execution_success", 1) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                
                # Points pour chaque action
                for i, action in enumerate(actions):
                    action_point = Point("energy_scenario_actions") \
                        .tag("scenario", scenario_name) \
                        .tag("action_type", action['type']) \
                        .tag("source", "scenario_engine") \
                        .field("action_index", i) \
                        .field("success", 1 if 'Error' not in action['result'] else 0) \
                        .time(datetime.utcnow(), WritePrecision.S)
                    
                    write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=action_point)
                    
                logger.info("üíæ Sc√©nario sauvegard√© dans InfluxDB")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde InfluxDB: {e}")
            
    def publish_status(self):
        """Publication du statut du moteur de sc√©narios"""
        try:
            status = {
                'timestamp': datetime.now().isoformat(),
                'active_scenarios_count': len(self.active_scenarios),
                'active_scenarios': list(self.active_scenarios.keys()),
                'total_scenarios_available': len(self.scenario_rules),
                'engine_status': 'running',
                'version': '{{ energy_ai.version | default("1.0.0") }}'
            }
            
            topic = "{{ mqtt_ai.topics.scenarios | default('energy/ai/scenarios') }}/status"
            self.mqtt_client.publish(topic, json.dumps(status, indent=2), qos=1)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur publication statut: {e}")
            
    def cleanup_old_scenarios(self):
        """Nettoyage des anciens sc√©narios"""
        current_time = datetime.now()
        to_remove = []
        
        for scenario_name, info in self.active_scenarios.items():
            age = current_time - info['activated_at']
            if age.total_seconds() > 3600:  # Plus d'1 heure
                to_remove.append(scenario_name)
                
        for scenario_name in to_remove:
            logger.info(f"üßπ Nettoyage sc√©nario expir√©: {scenario_name}")
            del self.active_scenarios[scenario_name]
            
    def start(self):
        """D√©marrage du moteur de sc√©narios"""
        logger.info("üöÄ D√©marrage Energy Scenario Engine")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des t√¢ches
        schedule.every(5).minutes.do(self.publish_status)
        schedule.every(30).minutes.do(self.cleanup_old_scenarios)
        
        logger.info("‚úÖ Energy Scenario Engine op√©rationnel")
        logger.info(f"üìã {len(self.scenario_rules)} sc√©narios charg√©s: {list(self.scenario_rules.keys())}")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(30)  # V√©rification toutes les 30 secondes
                
        except KeyboardInterrupt:
            logger.info("üõë Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arr√™t"""
        logger.info("üßπ Nettoyage avant arr√™t")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("üëã Energy Scenario Engine arr√™t√© proprement")

def main():
    """Point d'entr√©e principal"""
    try:
        engine = EnergyScenarioEngine()
        engine.start()
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()