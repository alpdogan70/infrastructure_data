#!/usr/bin/env python3
"""
Cost Optimizer - Optimiseur de co√ªts √©nerg√©tiques
File: {{ energy_ai_paths.base | default('/opt/energy-ai') }}/cost_optimizer.py
Generated by Ansible - Energy Intelligence Role
"""

import json
import time
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WritePrecision
import schedule
import sys

# Configuration
MQTT_BROKER = "{{ mqtt_broker_host | default('localhost') }}"
MQTT_PORT = 1883
MQTT_USERNAME = "iot"
MQTT_PASSWORD = "iot123"

INFLUXDB_URL = "{{ influxdb_url | default('http://localhost:8086') }}"
INFLUXDB_TOKEN = "{{ influxdb_token.content | b64decode | trim if influxdb_token is defined else 'demo-token' }}"
INFLUXDB_ORG = "{{ influxdb_org | default('iot') }}"
INFLUXDB_BUCKET = "cost_optimization"

# Tarifs √©lectricit√© (‚Ç¨/kWh) - Simulation tarifs fran√ßais
ELECTRICITY_TARIFFS = {
    'peak_hours': {  # Heures pleines (8h-22h)
        'weekday': 0.1841,
        'weekend': 0.1658
    },
    'off_peak_hours': {  # Heures creuses (22h-8h)
        'weekday': 0.1470,
        'weekend': 0.1470
    },
    'injection_tariff': 0.10,  # Tarif de rachat solaire
    'grid_connection_fee': 15.50  # Abonnement mensuel
}

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ energy_ai_paths.logs | default('/opt/energy-ai/logs') }}/cost_optimizer.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('CostOptimizer')

class CostOptimizer:
    def __init__(self):
        self.mqtt_client = None
        self.influxdb_client = None
        self.current_data = {}
        self.daily_costs = {}
        self.optimization_strategies = {}
        self.initialize_strategies()
        
    def initialize_strategies(self):
        """Initialisation des strat√©gies d'optimisation"""
        self.optimization_strategies = {
            'battery_arbitrage': {
                'name': 'Arbitrage Batterie',
                'description': 'Optimisation charge/d√©charge selon tarifs',
                'enabled': True,
                'savings_potential': 0.15  # 15% d'√©conomies potentielles
            },
            'load_shifting': {
                'name': 'Report de Charge',
                'description': 'D√©placement consommation vers heures creuses',
                'enabled': True,
                'savings_potential': 0.12
            },
            'solar_maximization': {
                'name': 'Maximisation Solaire',
                'description': 'Optimisation autoconsommation solaire',
                'enabled': True,
                'savings_potential': 0.20
            },
            'demand_response': {
                'name': 'Effacement de Consommation',
                'description': 'R√©duction temporaire consommation',
                'enabled': True,
                'savings_potential': 0.08
            }
        }
        
        logger.info("‚úÖ Strat√©gies d'optimisation initialis√©es")
        
    def connect_mqtt(self):
        """Connexion au broker MQTT"""
        try:
            self.mqtt_client = mqtt.Client(client_id="cost-optimizer")
            self.mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
            
            def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logger.info(f"‚úÖ Connect√© au broker MQTT {MQTT_BROKER}")
                    # S'abonner aux topics de donn√©es √©nerg√©tiques
                    topics = [
                        "energy/+/+",
                        "{{ mqtt_ai.topics.predictions | default('energy/ai/predictions') }}/+",
                        "sensors/battery/+",
                        "sensors/solar/+",
                        "sensors/grid/+"
                    ]
                    for topic in topics:
                        client.subscribe(topic)
                        logger.info(f"üì° Abonn√© au topic: {topic}")
                else:
                    logger.error(f"‚ùå √âchec connexion MQTT: {rc}")
                    
            def on_message(client, userdata, msg):
                try:
                    topic = msg.topic
                    payload = json.loads(msg.payload.decode())
                    self.process_energy_data(topic, payload)
                except Exception as e:
                    logger.error(f"‚ùå Erreur traitement message MQTT: {e}")
                    
            self.mqtt_client.on_connect = on_connect
            self.mqtt_client.on_message = on_message
            self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            self.mqtt_client.loop_start()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion MQTT: {e}")
            
    def connect_influxdb(self):
        """Connexion √† InfluxDB"""
        try:
            self.influxdb_client = InfluxDBClient(
                url=INFLUXDB_URL,
                token=INFLUXDB_TOKEN,
                org=INFLUXDB_ORG
            )
            logger.info("‚úÖ Connect√© √† InfluxDB")
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion InfluxDB: {e}")
            
    def process_energy_data(self, topic, data):
        """Traitement des donn√©es √©nerg√©tiques"""
        try:
            self.current_data[topic] = {
                'data': data,
                'timestamp': datetime.now()
            }
            
            # D√©clencher optimisation si assez de donn√©es
            if len(self.current_data) >= 3:
                self.run_cost_optimization()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement donn√©es: {e}")
            
    def get_current_tariff(self):
        """Obtention du tarif √©lectrique actuel"""
        now = datetime.now()
        hour = now.hour
        is_weekend = now.weekday() >= 5
        
        # Heures pleines/creuses
        if 8 <= hour < 22:  # Heures pleines
            if is_weekend:
                return ELECTRICITY_TARIFFS['peak_hours']['weekend']
            else:
                return ELECTRICITY_TARIFFS['peak_hours']['weekday']
        else:  # Heures creuses
            return ELECTRICITY_TARIFFS['off_peak_hours']['weekday']
            
    def predict_tariff_evolution(self, hours_ahead=24):
        """Pr√©diction de l'√©volution des tarifs"""
        tariff_forecast = []
        base_time = datetime.now()
        
        for i in range(hours_ahead):
            future_time = base_time + timedelta(hours=i)
            hour = future_time.hour
            is_weekend = future_time.weekday() >= 5
            
            if 8 <= hour < 22:  # Heures pleines
                if is_weekend:
                    tariff = ELECTRICITY_TARIFFS['peak_hours']['weekend']
                else:
                    tariff = ELECTRICITY_TARIFFS['peak_hours']['weekday']
            else:  # Heures creuses
                tariff = ELECTRICITY_TARIFFS['off_peak_hours']['weekday']
                
            tariff_forecast.append({
                'timestamp': future_time.isoformat(),
                'tariff_eur_kwh': tariff,
                'period': 'peak' if 8 <= hour < 22 else 'off_peak',
                'is_weekend': is_weekend
            })
            
        return tariff_forecast
        
    def calculate_current_costs(self):
        """Calcul des co√ªts √©nerg√©tiques actuels"""
        try:
            current_tariff = self.get_current_tariff()
            
            # Extraction des donn√©es de consommation et production
            consumption_kw = self.extract_metric('consumption', 85.0)  # D√©faut 85kW
            solar_production_kw = self.extract_metric('solar_production', 0.0)
            battery_level = self.extract_metric('battery_level', 70.0)
            grid_power_kw = consumption_kw - solar_production_kw  # Simplifi√©
            
            # Calcul co√ªts (‚Ç¨/heure)
            if grid_power_kw > 0:  # Consommation depuis r√©seau
                hourly_cost = grid_power_kw * current_tariff
                grid_injection = 0
            else:  # Injection r√©seau
                hourly_cost = 0
                grid_injection = abs(grid_power_kw) * ELECTRICITY_TARIFFS['injection_tariff']
                
            return {
                'timestamp': datetime.now().isoformat(),
                'consumption_kw': consumption_kw,
                'solar_production_kw': solar_production_kw,
                'grid_power_kw': grid_power_kw,
                'current_tariff_eur_kwh': current_tariff,
                'hourly_cost_eur': round(hourly_cost, 4),
                'injection_revenue_eur': round(grid_injection, 4),
                'net_hourly_cost_eur': round(hourly_cost - grid_injection, 4),
                'battery_level_pct': battery_level
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur calcul co√ªts: {e}")
            return {}
            
    def extract_metric(self, metric_name, default_value):
        """Extraction d'une m√©trique des donn√©es courantes"""
        for topic, data_info in self.current_data.items():
            data = data_info['data']
            
            if metric_name == 'consumption' and 'consumption' in topic:
                return float(data.get('power', data.get('value', default_value)))
            elif metric_name == 'solar_production' and 'solar' in topic:
                return float(data.get('power', data.get('value', default_value)))
            elif metric_name == 'battery_level' and 'battery' in topic:
                return float(data.get('level', data.get('soc', default_value)))
                
        return default_value
        
    def optimize_battery_strategy(self, tariff_forecast):
        """Optimisation de la strat√©gie batterie"""
        try:
            current_battery = self.extract_metric('battery_level', 70.0)
            battery_capacity_kwh = 100  # Capacit√© batterie exemple
            
            recommendations = []
            
            # Analyser les prochaines 24h
            min_tariff = min(forecast['tariff_eur_kwh'] for forecast in tariff_forecast)
            max_tariff = max(forecast['tariff_eur_kwh'] for forecast in tariff_forecast)
            current_tariff = self.get_current_tariff()
            
            # Strat√©gie d'arbitrage
            if current_tariff <= min_tariff * 1.1:  # Tarif bas
                if current_battery < 90:
                    recommendations.append({
                        'action': 'charge_battery',
                        'reason': 'Tarif √©lectrique bas - Charger batterie',
                        'target_level': 90,
                        'potential_savings_eur': (max_tariff - current_tariff) * battery_capacity_kwh * 0.3
                    })
                    
            elif current_tariff >= max_tariff * 0.9:  # Tarif √©lev√©
                if current_battery > 30:
                    recommendations.append({
                        'action': 'discharge_battery',
                        'reason': 'Tarif √©lectrique √©lev√© - D√©charger batterie',
                        'target_level': 30,
                        'potential_savings_eur': (current_tariff - min_tariff) * battery_capacity_kwh * 0.4
                    })
                    
            # Pr√©diction heures creuses optimales
            off_peak_periods = [
                f for f in tariff_forecast[:8] 
                if f['period'] == 'off_peak'
            ]
            
            if off_peak_periods and current_battery < 80:
                next_off_peak = off_peak_periods[0]
                recommendations.append({
                    'action': 'schedule_charge',
                    'reason': 'Programmation charge heures creuses',
                    'schedule_time': next_off_peak['timestamp'],
                    'target_level': 85,
                    'potential_savings_eur': (current_tariff - next_off_peak['tariff_eur_kwh']) * 50
                })
                
            return recommendations
            
        except Exception as e:
            logger.error(f"‚ùå Erreur optimisation batterie: {e}")
            return []
            
    def optimize_load_scheduling(self):
        """Optimisation de la planification des charges"""
        try:
            recommendations = []
            current_hour = datetime.now().hour
            
            # Charges diff√©rables (exemples)
            deferrable_loads = [
                {'name': 'Backup servers', 'power_kw': 15, 'duration_hours': 2},
                {'name': 'Data processing', 'power_kw': 25, 'duration_hours': 1},
                {'name': 'Cooling pre-cooling', 'power_kw': 20, 'duration_hours': 3}
            ]
            
            current_tariff = self.get_current_tariff()
            off_peak_tariff = ELECTRICITY_TARIFFS['off_peak_hours']['weekday']
            
            # Si on est en heures pleines
            if 8 <= current_hour < 22:
                for load in deferrable_loads:
                    savings_per_hour = (current_tariff - off_peak_tariff) * load['power_kw']
                    total_savings = savings_per_hour * load['duration_hours']
                    
                    if total_savings > 0.50:  # Seuil minimum d'√©conomies
                        recommendations.append({
                            'action': 'defer_load',
                            'load_name': load['name'],
                            'reason': 'Report vers heures creuses',
                            'suggested_start_time': '22:00',
                            'potential_savings_eur': round(total_savings, 2)
                        })
                        
            return recommendations
            
        except Exception as e:
            logger.error(f"‚ùå Erreur optimisation charges: {e}")
            return []
            
    def calculate_solar_optimization(self):
        """Calcul optimisation solaire"""
        try:
            current_solar = self.extract_metric('solar_production', 0.0)
            current_consumption = self.extract_metric('consumption', 85.0)
            
            recommendations = []
            
            # Surplus solaire
            solar_surplus = current_solar - current_consumption
            
            if solar_surplus > 10:  # Surplus significatif
                injection_revenue = solar_surplus * ELECTRICITY_TARIFFS['injection_tariff']
                battery_value = solar_surplus * self.get_current_tariff()
                
                if battery_value > injection_revenue * 1.2:
                    recommendations.append({
                        'action': 'store_solar_surplus',
                        'reason': 'Stockage plus rentable que injection',
                        'surplus_kw': round(solar_surplus, 2),
                        'potential_additional_value_eur': round(battery_value - injection_revenue, 2)
                    })
                    
            # D√©ficit solaire mais batterie disponible
            elif solar_surplus < -5:  # Consommation > production
                battery_level = self.extract_metric('battery_level', 70.0)
                current_tariff = self.get_current_tariff()
                
                if battery_level > 40 and current_tariff > 0.16:
                    deficit = abs(solar_surplus)
                    battery_savings = deficit * (current_tariff - 0.10)  # Co√ªt stockage ~0.10‚Ç¨/kWh
                    
                    recommendations.append({
                        'action': 'use_battery_for_deficit',
                        'reason': 'Batterie moins ch√®re que r√©seau',
                        'deficit_kw': round(deficit, 2),
                        'potential_savings_eur': round(battery_savings, 2)
                    })
                    
            return recommendations
            
        except Exception as e:
            logger.error(f"‚ùå Erreur optimisation solaire: {e}")
            return []
            
    def run_cost_optimization(self):
        """Ex√©cution de l'optimisation compl√®te des co√ªts"""
        try:
            logger.info("üí∞ D√©marrage optimisation des co√ªts")
            
            # Calcul co√ªts actuels
            current_costs = self.calculate_current_costs()
            
            # Pr√©vision tarifs
            tariff_forecast = self.predict_tariff_evolution()
            
            # Optimisations sp√©cifiques
            battery_recommendations = self.optimize_battery_strategy(tariff_forecast)
            load_recommendations = self.optimize_load_scheduling()
            solar_recommendations = self.calculate_solar_optimization()
            
            # Compilation des r√©sultats
            optimization_results = {
                'timestamp': datetime.now().isoformat(),
                'current_costs': current_costs,
                'tariff_forecast_6h': tariff_forecast[:6],  # 6h de pr√©vision
                'recommendations': {
                    'battery_optimization': battery_recommendations,
                    'load_scheduling': load_recommendations,
                    'solar_optimization': solar_recommendations
                },
                'total_recommendations': len(battery_recommendations) + len(load_recommendations) + len(solar_recommendations),
                'potential_daily_savings_eur': self.calculate_total_savings(
                    battery_recommendations, load_recommendations, solar_recommendations
                ),
                'optimizer_version': '{{ energy_ai.version | default("1.0.0") }}'
            }
            
            # Publication et sauvegarde
            self.publish_optimization_results(optimization_results)
            self.save_to_influxdb(optimization_results)
            
            logger.info(f"‚úÖ Optimisation termin√©e - {optimization_results['total_recommendations']} recommandations")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur optimisation co√ªts: {e}")
            
    def calculate_total_savings(self, battery_recs, load_recs, solar_recs):
        """Calcul du total des √©conomies potentielles"""
        try:
            total_savings = 0.0
            
            # √âconomies batterie
            for rec in battery_recs:
                total_savings += rec.get('potential_savings_eur', 0)
                
            # √âconomies charges diff√©r√©es
            for rec in load_recs:
                total_savings += rec.get('potential_savings_eur', 0)
                
            # Optimisation solaire
            for rec in solar_recs:
                total_savings += rec.get('potential_additional_value_eur', 0)
                total_savings += rec.get('potential_savings_eur', 0)
                
            return round(total_savings, 2)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur calcul √©conomies totales: {e}")
            return 0.0
            
    def publish_optimization_results(self, results):
        """Publication des r√©sultats d'optimisation"""
        try:
            if self.mqtt_client:
                # R√©sultats complets
                results_topic = "{{ mqtt_ai.topics.cost_optimization | default('energy/ai/costs') }}/results"
                self.mqtt_client.publish(results_topic, json.dumps(results, indent=2), qos=1)
                
                # Recommandations urgentes (√©conomies > 1‚Ç¨)
                urgent_recommendations = []
                for category, recs in results['recommendations'].items():
                    for rec in recs:
                        savings = rec.get('potential_savings_eur', 0) + rec.get('potential_additional_value_eur', 0)
                        if savings > 1.0:
                            urgent_recommendations.append({
                                'category': category,
                                'action': rec['action'],
                                'savings_eur': savings,
                                'priority': 'high' if savings > 5.0 else 'medium'
                            })
                            
                if urgent_recommendations:
                    urgent_topic = "{{ mqtt_ai.topics.cost_optimization | default('energy/ai/costs') }}/urgent"
                    urgent_data = {
                        'timestamp': datetime.now().isoformat(),
                        'urgent_recommendations': urgent_recommendations,
                        'total_urgent_savings_eur': sum(r['savings_eur'] for r in urgent_recommendations)
                    }
                    self.mqtt_client.publish(urgent_topic, json.dumps(urgent_data, indent=2), qos=2)
                    
                logger.info("üì° R√©sultats optimisation publi√©s sur MQTT")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur publication r√©sultats: {e}")
            
    def save_to_influxdb(self, results):
        """Sauvegarde des r√©sultats dans InfluxDB"""
        try:
            if self.influxdb_client:
                write_api = self.influxdb_client.write_api()
                
                # Point principal d'optimisation
                point = Point("cost_optimization") \
                    .tag("source", "cost_optimizer") \
                    .tag("version", results['optimizer_version']) \
                    .field("total_recommendations", results['total_recommendations']) \
                    .field("potential_daily_savings_eur", results['potential_daily_savings_eur']) \
                    .field("current_hourly_cost_eur", results['current_costs'].get('hourly_cost_eur', 0)) \
                    .field("current_tariff_eur_kwh", results['current_costs'].get('current_tariff_eur_kwh', 0)) \
                    .field("battery_level_pct", results['current_costs'].get('battery_level_pct', 0)) \
                    .time(datetime.utcnow(), WritePrecision.S)
                
                write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=point)
                
                # Points pour chaque cat√©gorie de recommandations
                for category, recs in results['recommendations'].items():
                    if recs:
                        category_point = Point("cost_optimization_recommendations") \
                            .tag("category", category) \
                            .tag("source", "cost_optimizer") \
                            .field("recommendations_count", len(recs)) \
                            .field("category_savings_eur", sum(
                                r.get('potential_savings_eur', 0) + r.get('potential_additional_value_eur', 0) 
                                for r in recs
                            )) \
                            .time(datetime.utcnow(), WritePrecision.S)
                        
                        write_api.write(bucket=INFLUXDB_BUCKET, org=INFLUXDB_ORG, record=category_point)
                        
                logger.info("üíæ R√©sultats sauvegard√©s dans InfluxDB")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde InfluxDB: {e}")
            
    def generate_daily_report(self):
        """G√©n√©ration du rapport quotidien de co√ªts"""
        try:
            today = datetime.now().date()
            
            # Simulation de donn√©es quotidiennes
            daily_report = {
                'date': today.isoformat(),
                'total_consumption_kwh': round(85 * 24 + np.random.normal(0, 100), 2),
                'total_solar_production_kwh': round(45 * 12 + np.random.normal(0, 50), 2),
                'total_cost_eur': round(np.random.uniform(15, 35), 2),
                'savings_realized_eur': round(np.random.uniform(2, 8), 2),
                'optimization_efficiency_pct': round(np.random.uniform(75, 95), 1),
                'recommendations_followed': np.random.randint(8, 15),
                'top_saving_strategy': 'battery_arbitrage'
            }
            
            # Publication du rapport
            report_topic = "{{ mqtt_ai.topics.cost_optimization | default('energy/ai/costs') }}/daily_report"
            self.mqtt_client.publish(report_topic, json.dumps(daily_report, indent=2), qos=1)
            
            logger.info(f"üìä Rapport quotidien g√©n√©r√© - √âconomies: {daily_report['savings_realized_eur']}‚Ç¨")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©ration rapport quotidien: {e}")
            
    def start(self):
        """D√©marrage du service d'optimisation des co√ªts"""
        logger.info("üöÄ D√©marrage Cost Optimizer")
        
        # Connexions
        self.connect_mqtt()
        self.connect_influxdb()
        
        # Programmation des t√¢ches
        schedule.every(10).minutes.do(self.run_cost_optimization)
        schedule.every().hour.at(":00").do(self.run_cost_optimization)
        schedule.every().day.at("23:55").do(self.generate_daily_report)
        
        # Premi√®re optimisation imm√©diate
        time.sleep(5)  # Attendre les premi√®res donn√©es
        self.run_cost_optimization()
        
        logger.info("‚úÖ Cost Optimizer op√©rationnel")
        logger.info(f"üí∞ {len(self.optimization_strategies)} strat√©gies d'optimisation actives")
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)
                
        except KeyboardInterrupt:
            logger.info("üõë Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
        finally:
            self.cleanup()
            
    def cleanup(self):
        """Nettoyage avant arr√™t"""
        logger.info("üßπ Nettoyage avant arr√™t")
        
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()
            
        if self.influxdb_client:
            self.influxdb_client.close()
            
        logger.info("üëã Cost Optimizer arr√™t√© proprement")

def main():
    """Point d'entr√©e principal"""
    try:
        optimizer = CostOptimizer()
        optimizer.start()
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()